# 데이터 표현 기초

## 개요

컴퓨터는 모든 데이터를 0과 1의 이진수로 표현합니다. 이 레슨에서는 진법의 개념, 진법 변환 방법, 데이터 단위, 그리고 보수의 개념을 학습합니다. 이는 컴퓨터가 데이터를 어떻게 처리하는지 이해하는 기초가 됩니다.

**난이도**: ⭐ (기초)

---

## 목차

1. [진법의 이해](#1-진법의-이해)
2. [이진수 (Binary)](#2-이진수-binary)
3. [8진수 (Octal)](#3-8진수-octal)
4. [16진수 (Hexadecimal)](#4-16진수-hexadecimal)
5. [진법 변환](#5-진법-변환)
6. [데이터 단위](#6-데이터-단위)
7. [보수의 개념](#7-보수의-개념)
8. [연습 문제](#8-연습-문제)

---

## 1. 진법의 이해

### 진법(Number System)이란?

진법은 수를 표현하는 방식으로, 기수(radix 또는 base)를 사용하여 숫자를 나타냅니다.

```
┌─────────────────────────────────────────────────────────┐
│                     진법의 종류                          │
├─────────────┬─────────┬─────────────────────────────────┤
│   진법      │  기수   │         사용하는 숫자            │
├─────────────┼─────────┼─────────────────────────────────┤
│  2진법      │   2     │  0, 1                           │
│  8진법      │   8     │  0, 1, 2, 3, 4, 5, 6, 7         │
│  10진법     │   10    │  0, 1, 2, 3, 4, 5, 6, 7, 8, 9   │
│  16진법     │   16    │  0-9, A, B, C, D, E, F          │
└─────────────┴─────────┴─────────────────────────────────┘
```

### 자릿값(Place Value)의 원리

모든 진법에서 각 자리는 기수의 거듭제곱 값을 가집니다.

```
10진수 1234의 자릿값:
    1    2    3    4
   10³  10²  10¹  10⁰
 =1000 =100  =10   =1

1234 = 1×10³ + 2×10² + 3×10¹ + 4×10⁰
     = 1000 + 200 + 30 + 4
     = 1234

2진수 1101의 자릿값:
    1    1    0    1
   2³   2²   2¹   2⁰
   =8   =4   =2   =1

1101₂ = 1×2³ + 1×2² + 0×2¹ + 1×2⁰
      = 8 + 4 + 0 + 1
      = 13₁₀
```

---

## 2. 이진수 (Binary)

### 이진수의 특성

컴퓨터가 이진수를 사용하는 이유:

```
┌─────────────────────────────────────────────────────────┐
│              왜 컴퓨터는 이진수를 사용하는가?            │
├─────────────────────────────────────────────────────────┤
│  1. 전기 신호의 두 상태 (ON/OFF)와 대응                 │
│  2. 노이즈에 강함 (두 상태만 구분하면 됨)               │
│  3. 논리 연산과 직접 대응 (참/거짓)                     │
│  4. 회로 설계가 단순함                                  │
└─────────────────────────────────────────────────────────┘

     전압
       │
   5V ─┤  ████████           ████████
       │          │         │
   0V ─┤──────────┴─────────┴────────── 시간
       │
         HIGH(1)    LOW(0)   HIGH(1)
```

### 이진수 표기

```
이진수 표기 방법:
- 하위 첨자: 1010₂
- 접두사: 0b1010 (프로그래밍에서 많이 사용)
- 접미사: 1010b

2의 거듭제곱 (암기 권장):
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ 2⁰  │ 2¹  │ 2²  │ 2³  │ 2⁴  │ 2⁵  │ 2⁶  │ 2⁷  │ 2⁸  │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│  1  │  2  │  4  │  8  │ 16  │ 32  │ 64  │ 128 │ 256 │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

┌─────┬─────┬──────┬──────┬───────┐
│ 2⁹  │ 2¹⁰ │ 2¹¹  │ 2¹²  │ 2¹⁶   │
├─────┼─────┼──────┼──────┼───────┤
│ 512 │1024 │ 2048 │ 4096 │ 65536 │
└─────┴─────┴──────┴──────┴───────┘
```

### 이진수 덧셈

```
이진수 덧셈 규칙:
  0 + 0 = 0
  0 + 1 = 1
  1 + 0 = 1
  1 + 1 = 10 (0을 쓰고 1 올림)
  1 + 1 + 1 = 11 (1을 쓰고 1 올림)

예시: 1011 + 1101
        1 1     (올림)
        1 0 1 1
      + 1 1 0 1
      ─────────
      1 1 0 0 0

검증: 11₁₀ + 13₁₀ = 24₁₀ = 11000₂ ✓
```

### 이진수 뺄셈

```
이진수 뺄셈 규칙:
  0 - 0 = 0
  1 - 0 = 1
  1 - 1 = 0
  0 - 1 = 1 (상위 비트에서 빌림)

예시: 1101 - 1011
        0 10    (빌림)
        1 1 0 1
      - 1 0 1 1
      ─────────
        0 0 1 0

검증: 13₁₀ - 11₁₀ = 2₁₀ = 10₂ ✓
```

---

## 3. 8진수 (Octal)

### 8진수의 특성

```
8진수는 0~7까지의 숫자를 사용합니다.
2³ = 8이므로, 이진수 3자리가 8진수 1자리에 대응됩니다.

이진수와 8진수의 관계:
┌────────┬────────┐
│ 이진수 │ 8진수  │
├────────┼────────┤
│  000   │   0    │
│  001   │   1    │
│  010   │   2    │
│  011   │   3    │
│  100   │   4    │
│  101   │   5    │
│  110   │   6    │
│  111   │   7    │
└────────┴────────┘
```

### 8진수 표기

```
8진수 표기 방법:
- 하위 첨자: 753₈
- 접두사: 0o753 (Python) 또는 0753 (C)

예시: 이진수 → 8진수
110 101 011₂
 6   5   3₈ = 653₈

예시: 8진수 → 이진수
752₈ = 111 101 010₂
```

### 8진수의 용도

```
┌─────────────────────────────────────────────────────────┐
│                    8진수의 활용                          │
├─────────────────────────────────────────────────────────┤
│  1. Unix/Linux 파일 권한 (chmod 755)                    │
│     - 755 = rwxr-xr-x                                   │
│     - 7 = 111₂ = rwx (읽기+쓰기+실행)                   │
│     - 5 = 101₂ = r-x (읽기+실행)                        │
│                                                         │
│  2. 과거 컴퓨터 시스템 (PDP-8 등)                       │
│  3. 아스키 코드 표현                                    │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 16진수 (Hexadecimal)

### 16진수의 특성

```
16진수는 0~9와 A~F(10~15)를 사용합니다.
2⁴ = 16이므로, 이진수 4자리가 16진수 1자리에 대응됩니다.

이진수와 16진수의 관계:
┌────────┬────────┬────────┐
│ 10진수 │ 이진수 │ 16진수 │
├────────┼────────┼────────┤
│   0    │  0000  │   0    │
│   1    │  0001  │   1    │
│   2    │  0010  │   2    │
│   3    │  0011  │   3    │
│   4    │  0100  │   4    │
│   5    │  0101  │   5    │
│   6    │  0110  │   6    │
│   7    │  0111  │   7    │
│   8    │  1000  │   8    │
│   9    │  1001  │   9    │
│  10    │  1010  │   A    │
│  11    │  1011  │   B    │
│  12    │  1100  │   C    │
│  13    │  1101  │   D    │
│  14    │  1110  │   E    │
│  15    │  1111  │   F    │
└────────┴────────┴────────┘
```

### 16진수 표기

```
16진수 표기 방법:
- 하위 첨자: 2AF₁₆
- 접두사: 0x2AF (가장 많이 사용)
- 접미사: 2AFh

예시: 이진수 → 16진수
1010 1111 0011₂
 A    F    3₁₆ = 0xAF3

예시: 16진수 → 이진수
0x3E8 = 0011 1110 1000₂
```

### 16진수의 용도

```
┌─────────────────────────────────────────────────────────┐
│                   16진수의 활용                          │
├─────────────────────────────────────────────────────────┤
│  1. 메모리 주소 표현                                    │
│     - 0x7FFE1234                                        │
│                                                         │
│  2. 색상 코드 (RGB)                                     │
│     - #FF5733 = Red(FF) Green(57) Blue(33)              │
│     - 각 색상은 0~255 (0x00~0xFF)                       │
│                                                         │
│  3. MAC 주소                                            │
│     - 00:1A:2B:3C:4D:5E                                 │
│                                                         │
│  4. 기계어/어셈블리 코드                                │
│     - MOV AX, 0x1234                                    │
│                                                         │
│  5. 유니코드/ASCII 코드                                 │
│     - 'A' = 0x41 = 65                                   │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 진법 변환

### 5.1 10진수 → 2진수 변환

**방법 1: 나눗셈 이용 (정수 부분)**

```
10진수 25를 2진수로 변환:

25 ÷ 2 = 12 ... 나머지 1  ↑
12 ÷ 2 =  6 ... 나머지 0  │
 6 ÷ 2 =  3 ... 나머지 0  │ 아래에서 위로 읽기
 3 ÷ 2 =  1 ... 나머지 1  │
 1 ÷ 2 =  0 ... 나머지 1  │

결과: 25₁₀ = 11001₂
```

**방법 2: 곱셈 이용 (소수 부분)**

```
10진수 0.625를 2진수로 변환:

0.625 × 2 = 1.25  → 정수부 1  ↓
0.25  × 2 = 0.5   → 정수부 0  │
0.5   × 2 = 1.0   → 정수부 1  │ 위에서 아래로 읽기
0.0   (종료)                  ↓

결과: 0.625₁₀ = 0.101₂
```

### 5.2 2진수 → 10진수 변환

```
이진수 110101을 10진수로 변환:

   1    1    0    1    0    1
  2⁵   2⁴   2³   2²   2¹   2⁰
  32   16    8    4    2    1

= 1×32 + 1×16 + 0×8 + 1×4 + 0×2 + 1×1
= 32 + 16 + 0 + 4 + 0 + 1
= 53₁₀
```

### 5.3 2진수 ↔ 16진수 변환

```
이진수 → 16진수: 4비트씩 묶어서 변환

  1011 1010 0110 1111₂
   B    A    6    F
= 0xBA6F

16진수 → 이진수: 각 자리를 4비트로 변환

0x2F5 = 0010 1111 0101₂
        2    F    5
```

### 5.4 10진수 ↔ 16진수 변환

```
10진수 → 16진수: 16으로 나누기

500 ÷ 16 = 31 ... 나머지 4   ↑
 31 ÷ 16 =  1 ... 나머지 15 (F)  │
  1 ÷ 16 =  0 ... 나머지 1   │

500₁₀ = 0x1F4

16진수 → 10진수: 자릿값 계산

0x1F4 = 1×16² + 15×16¹ + 4×16⁰
      = 256 + 240 + 4
      = 500₁₀
```

### 진법 변환 요약 다이어그램

```
           ┌──────────────────┐
           │     10진수       │
           └────────┬─────────┘
          ÷2       │        ÷16
      나머지 역순  │    나머지 역순
                   │
    ┌──────────────┼──────────────┐
    │              │              │
    ▼              │              ▼
┌───────┐          │         ┌────────┐
│ 2진수 │←─────────┼─────────→│ 16진수 │
└───────┘   4비트 묶기        └────────┘
            각 자리를
            4비트 확장
```

### 진법 변환 빠른 참조표

```
┌──────────┬──────────┬──────────┬──────────┐
│  10진수  │  2진수   │  8진수   │  16진수  │
├──────────┼──────────┼──────────┼──────────┤
│    0     │   0000   │    0     │    0     │
│    1     │   0001   │    1     │    1     │
│    2     │   0010   │    2     │    2     │
│    3     │   0011   │    3     │    3     │
│    4     │   0100   │    4     │    4     │
│    5     │   0101   │    5     │    5     │
│    6     │   0110   │    6     │    6     │
│    7     │   0111   │    7     │    7     │
│    8     │   1000   │   10     │    8     │
│    9     │   1001   │   11     │    9     │
│   10     │   1010   │   12     │    A     │
│   11     │   1011   │   13     │    B     │
│   12     │   1100   │   14     │    C     │
│   13     │   1101   │   15     │    D     │
│   14     │   1110   │   16     │    E     │
│   15     │   1111   │   17     │    F     │
│   16     │  10000   │   20     │   10     │
│   32     │ 100000   │   40     │   20     │
│   64     │ 1000000  │  100     │   40     │
│  128     │10000000  │  200     │   80     │
│  255     │11111111  │  377     │   FF     │
│  256     │100000000 │  400     │  100     │
└──────────┴──────────┴──────────┴──────────┘
```

---

## 6. 데이터 단위

### 기본 단위

```
┌─────────────────────────────────────────────────────────┐
│                    데이터 단위 계층                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  비트 (bit)                                             │
│    └── 0 또는 1, 정보의 최소 단위                       │
│                                                         │
│  니블 (nibble)                                          │
│    └── 4비트 = 16진수 한 자리                           │
│                                                         │
│  바이트 (byte)                                          │
│    └── 8비트 = 문자 하나 표현 가능                      │
│                                                         │
│  워드 (word)                                            │
│    └── CPU가 한 번에 처리하는 데이터 크기               │
│        (16비트, 32비트, 64비트 등)                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 비트와 바이트

```
1 바이트 = 8 비트

┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ bit7│ bit6│ bit5│ bit4│ bit3│ bit2│ bit1│ bit0│
│(MSB)│     │     │     │     │     │     │(LSB)│
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
  2⁷    2⁶    2⁵    2⁴    2³    2²    2¹    2⁰
 128    64    32    16     8     4     2     1

MSB (Most Significant Bit): 가장 왼쪽 비트 (최상위 비트)
LSB (Least Significant Bit): 가장 오른쪽 비트 (최하위 비트)

1 바이트로 표현 가능한 값:
- 부호 없는 정수: 0 ~ 255 (2⁸ = 256가지)
- 부호 있는 정수: -128 ~ 127
```

### 워드 크기

```
┌──────────────────────────────────────────────────────────┐
│                   시스템별 워드 크기                      │
├────────────────┬──────────┬───────────────────────────────┤
│    시스템      │ 워드 크기│          표현 범위            │
├────────────────┼──────────┼───────────────────────────────┤
│  8비트 시스템  │  1바이트 │  0 ~ 255                      │
│  16비트 시스템 │  2바이트 │  0 ~ 65,535                   │
│  32비트 시스템 │  4바이트 │  0 ~ 4,294,967,295            │
│  64비트 시스템 │  8바이트 │  0 ~ 18,446,744,073,709,551,615│
└────────────────┴──────────┴───────────────────────────────┘
```

### 대용량 단위

```
┌────────────────────────────────────────────────────────────┐
│                    저장 용량 단위                           │
├────────────┬────────────────────┬──────────────────────────┤
│    단위    │    2진 접두어      │     10진 접두어          │
│            │   (IEC 표준)       │    (SI 표준)             │
├────────────┼────────────────────┼──────────────────────────┤
│  킬로 (K)  │ 1 KiB = 2¹⁰ = 1,024│ 1 KB = 10³ = 1,000      │
│  메가 (M)  │ 1 MiB = 2²⁰        │ 1 MB = 10⁶              │
│  기가 (G)  │ 1 GiB = 2³⁰        │ 1 GB = 10⁹              │
│  테라 (T)  │ 1 TiB = 2⁴⁰        │ 1 TB = 10¹²             │
│  페타 (P)  │ 1 PiB = 2⁵⁰        │ 1 PB = 10¹⁵             │
│  엑사 (E)  │ 1 EiB = 2⁶⁰        │ 1 EB = 10¹⁸             │
└────────────┴────────────────────┴──────────────────────────┘

실제 용량 차이 예시:
- 1 TB 하드디스크 (10진): 1,000,000,000,000 바이트
- 운영체제 표시 (2진): 약 931 GiB

계산: 1,000,000,000,000 ÷ 1,073,741,824 ≈ 931 GiB
```

---

## 7. 보수의 개념

### 보수(Complement)란?

```
보수는 어떤 수를 특정 기준에서 뺀 값입니다.
컴퓨터에서 보수는 뺄셈을 덧셈으로 변환하는 데 사용됩니다.

┌─────────────────────────────────────────────────────────┐
│                     보수의 종류                          │
├─────────────────────────────────────────────────────────┤
│  r-1의 보수: 각 자릿수를 (r-1)에서 뺀 값                │
│  r의 보수: (r-1의 보수) + 1                             │
│                                                         │
│  이진수에서:                                            │
│  - 1의 보수: 각 비트를 반전 (0↔1)                       │
│  - 2의 보수: 1의 보수 + 1                               │
└─────────────────────────────────────────────────────────┘
```

### 1의 보수 (One's Complement)

```
1의 보수: 모든 비트를 반전 (0→1, 1→0)

예시: 8비트에서 00101101의 1의 보수

  원래 값:    0 0 1 0 1 1 0 1
                ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
  1의 보수:   1 1 0 1 0 0 1 0

검증: 45₁₀ → 1의 보수 → 210₁₀
      45 + 210 = 255 = 2⁸ - 1 ✓
```

### 2의 보수 (Two's Complement)

```
2의 보수: 1의 보수 + 1 (또는 가장 오른쪽 1부터 왼쪽은 반전)

예시: 8비트에서 00101101의 2의 보수

방법 1: 1의 보수 + 1
  원래 값:    0 0 1 0 1 1 0 1  (45)
  1의 보수:   1 1 0 1 0 0 1 0  (210)
           +                 1
  ─────────────────────────────
  2의 보수:   1 1 0 1 0 0 1 1  (211)

방법 2: 오른쪽에서 첫 번째 1까지 유지, 나머지 반전
  원래 값:    0 0 1 0 1 1 0 1
                      ↑
              여기까지 유지, 왼쪽은 반전
  2의 보수:   1 1 0 1 0 0 1 1

검증: 45 + 211 = 256 = 2⁸ ✓
```

### 2의 보수의 중요성

```
┌─────────────────────────────────────────────────────────┐
│              2의 보수가 중요한 이유                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 0의 표현이 유일함                                   │
│     - 1의 보수: +0 (00000000), -0 (11111111)            │
│     - 2의 보수: 0 (00000000) 하나뿐                     │
│                                                         │
│  2. 뺄셈을 덧셈으로 변환                                │
│     A - B = A + (-B) = A + (B의 2의 보수)               │
│                                                         │
│  3. 덧셈기 하나로 덧셈/뺄셈 모두 처리                   │
│                                                         │
│  4. 오버플로우 검출이 용이                              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2의 보수를 이용한 뺄셈

```
예시: 7 - 3 을 8비트 2의 보수로 계산

  7 = 00000111
  3 = 00000011

  3의 2의 보수 = 11111101 (= -3)

    0 0 0 0 0 1 1 1   (7)
  + 1 1 1 1 1 1 0 1   (-3, 3의 2의 보수)
  ─────────────────────
  1 0 0 0 0 0 1 0 0
  ↑
  캐리 무시 (8비트이므로)

  결과: 00000100 = 4 ✓
```

### 부호 있는 정수의 범위

```
n비트 2의 보수 표현 범위: -2^(n-1) ~ 2^(n-1) - 1

┌───────────┬──────────────────────────────────────────────┐
│  비트 수  │               표현 범위                       │
├───────────┼──────────────────────────────────────────────┤
│  4비트    │  -8 ~ 7                                      │
│  8비트    │  -128 ~ 127                                  │
│  16비트   │  -32,768 ~ 32,767                            │
│  32비트   │  -2,147,483,648 ~ 2,147,483,647              │
│  64비트   │  약 -9.2×10¹⁸ ~ 9.2×10¹⁸                     │
└───────────┴──────────────────────────────────────────────┘

8비트 2의 보수 숫자 원:

         0 (00000000)
          ↑
    -1 (11111111)  1 (00000001)
         ↖        ↗
          ·      ·
           ·    ·
    -128    ·  ·     127
  (10000000)  (01111111)
```

---

## 8. 연습 문제

### 기초 문제

**1. 다음 10진수를 2진수로 변환하시오.**
   - (a) 42
   - (b) 100
   - (c) 255

**2. 다음 2진수를 10진수로 변환하시오.**
   - (a) 10110
   - (b) 11111111
   - (c) 10000000

**3. 다음 2진수를 16진수로 변환하시오.**
   - (a) 11011010
   - (b) 101111110000
   - (c) 11111111111111111111111111111111

**4. 다음 16진수를 2진수로 변환하시오.**
   - (a) 0xAB
   - (b) 0x1234
   - (c) 0xDEADBEEF

### 계산 문제

**5. 다음 이진수 덧셈을 수행하시오.**
   - (a) 1011 + 1101
   - (b) 11111111 + 00000001
   - (c) 10101010 + 01010101

**6. 8비트 2의 보수 표현에서:**
   - (a) -45의 이진 표현은?
   - (b) 11101100의 10진수 값은?
   - (c) 7 - 12의 결과는?

**7. 다음 10진 소수를 이진수로 변환하시오 (소수점 이하 4자리까지).**
   - (a) 0.5
   - (b) 0.25
   - (c) 0.1

### 심화 문제

**8. 1 GiB와 1 GB의 차이는 몇 바이트인가?**

**9. 32비트 시스템에서 메모리 주소 지정이 최대 4GB로 제한되는 이유를 설명하시오.**

**10. 다음 상황을 분석하시오:**
```c
signed char a = 127;
a = a + 1;
// a의 값은?
```

---

<details>
<summary>정답</summary>

**1. 10진수 → 2진수**
- (a) 42 = 101010
- (b) 100 = 1100100
- (c) 255 = 11111111

**2. 2진수 → 10진수**
- (a) 10110 = 22
- (b) 11111111 = 255
- (c) 10000000 = 128

**3. 2진수 → 16진수**
- (a) 11011010 = 0xDA
- (b) 101111110000 = 0xBF0
- (c) 11111111111111111111111111111111 = 0xFFFFFFFF

**4. 16진수 → 2진수**
- (a) 0xAB = 10101011
- (b) 0x1234 = 0001001000110100
- (c) 0xDEADBEEF = 11011110101011011011111011101111

**5. 이진수 덧셈**
- (a) 1011 + 1101 = 11000 (11 + 13 = 24)
- (b) 11111111 + 00000001 = 100000000 (오버플로우 발생 시 결과에 따라 다름)
- (c) 10101010 + 01010101 = 11111111 (170 + 85 = 255)

**6. 2의 보수**
- (a) -45 = 11010011 (45 = 00101101, 보수 = 11010011)
- (b) 11101100 = -20 (MSB가 1이므로 음수, 보수 = 00010100 = 20)
- (c) 7 - 12 = -5 = 11111011

**7. 10진 소수 → 이진수**
- (a) 0.5 = 0.1
- (b) 0.25 = 0.01
- (c) 0.1 ≈ 0.0001 (정확히는 0.0001100110011... 무한 반복)

**8.**
- 1 GiB = 1,073,741,824 바이트
- 1 GB = 1,000,000,000 바이트
- 차이 = 73,741,824 바이트 ≈ 70.3 MiB

**9.** 32비트 시스템은 32비트 주소를 사용하므로 2³² = 4,294,967,296개의 주소를 지정할 수 있습니다. 각 주소가 1바이트를 가리키므로 최대 4GB(약 4GiB)의 메모리만 직접 접근할 수 있습니다.

**10.** a = -128. signed char의 범위는 -128~127이므로, 127+1은 오버플로우가 발생하여 -128이 됩니다. 이는 2의 보수 표현에서 01111111(127) + 1 = 10000000(-128)이기 때문입니다.

</details>

---

## 다음 단계

- [03_Integer_Float_Representation.md](./03_Integer_Float_Representation.md) - 정수와 부동소수점 표현의 상세

---

## 참고 자료

- Computer Organization and Design (Patterson & Hennessy)
- Digital Design (Morris Mano)
- [Binary, Hexadecimal, Octal - CS101](https://web.stanford.edu/class/cs101/)
- [Two's Complement - Wikipedia](https://en.wikipedia.org/wiki/Two%27s_complement)
