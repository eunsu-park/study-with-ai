# 컴퓨터 시스템 개요

## 개요

컴퓨터는 데이터를 입력받아 처리하고 결과를 출력하는 전자 장치입니다. 이 레슨에서는 컴퓨터의 역사, 기본 구조, 그리고 하드웨어와 소프트웨어의 관계를 학습합니다.

---

## 목차

1. [컴퓨터의 역사](#1-컴퓨터의-역사)
2. [폰 노이만 구조](#2-폰-노이만-구조)
3. [하드웨어 구성요소](#3-하드웨어-구성요소)
4. [소프트웨어 계층](#4-소프트웨어-계층)
5. [성능 측정](#5-성능-측정)
6. [연습 문제](#6-연습-문제)

---

## 1. 컴퓨터의 역사

### 세대별 발전

| 세대 | 시기 | 핵심 기술 | 특징 |
|------|------|-----------|------|
| 1세대 | 1940~1950년대 | 진공관 | ENIAC, 대형, 고열, 저신뢰성 |
| 2세대 | 1950~1960년대 | 트랜지스터 | 소형화, 저전력, COBOL/FORTRAN |
| 3세대 | 1960~1970년대 | 집적회로(IC) | 운영체제, 멀티프로그래밍 |
| 4세대 | 1970년대~현재 | VLSI/ULSI | 마이크로프로세서, PC |
| 5세대 | 현재~미래 | AI/양자컴퓨터 | 병렬처리, 인공지능 |

### 주요 이정표

```
1946: ENIAC (최초의 범용 전자 컴퓨터)
1947: 트랜지스터 발명 (벨 연구소)
1958: 집적회로 발명 (Jack Kilby)
1971: Intel 4004 (최초의 상용 마이크로프로세서)
1981: IBM PC
2007: iPhone (모바일 컴퓨팅 시대)
```

---

## 2. 폰 노이만 구조

### 핵심 개념

폰 노이만(John von Neumann)이 1945년에 제안한 컴퓨터 구조로, 현대 대부분의 컴퓨터가 이 구조를 따릅니다.

```
┌─────────────────────────────────────────┐
│              CPU (중앙처리장치)           │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  │
│  │  제어   │  │   ALU   │  │ 레지스터 │  │
│  │  장치   │  │(연산장치)│  │         │  │
│  └─────────┘  └─────────┘  └─────────┘  │
└──────────────────┬──────────────────────┘
                   │ 시스템 버스
     ┌─────────────┼─────────────┐
     │             │             │
┌────┴────┐  ┌─────┴─────┐  ┌────┴────┐
│  메모리  │  │  입력장치  │  │ 출력장치 │
│ (RAM)   │  │(키보드 등) │  │(모니터 등)│
└─────────┘  └───────────┘  └─────────┘
```

### 핵심 원칙

1. **저장 프로그램 개념**: 프로그램과 데이터가 같은 메모리에 저장
2. **순차 실행**: 명령어를 순차적으로 하나씩 실행
3. **이진 표현**: 모든 데이터는 이진수로 표현

### 폰 노이만 병목

```
CPU와 메모리 간 데이터 전송 속도가 전체 성능의 병목

CPU 속도 >> 메모리 속도

해결책:
- 캐시 메모리
- 파이프라이닝
- 다중 버스
```

---

## 3. 하드웨어 구성요소

### 3.1 중앙처리장치 (CPU)

```
┌────────────────────────────────────────┐
│                  CPU                    │
│  ┌──────────────────────────────────┐  │
│  │         제어 장치 (CU)            │  │
│  │  - 명령어 해독                    │  │
│  │  - 실행 순서 제어                 │  │
│  │  - 제어 신호 생성                 │  │
│  └──────────────────────────────────┘  │
│  ┌──────────────────────────────────┐  │
│  │      산술논리장치 (ALU)            │  │
│  │  - 산술 연산 (+, -, *, /)         │  │
│  │  - 논리 연산 (AND, OR, NOT)       │  │
│  │  - 비교 연산                      │  │
│  └──────────────────────────────────┘  │
│  ┌──────────────────────────────────┐  │
│  │         레지스터                  │  │
│  │  - PC (프로그램 카운터)           │  │
│  │  - IR (명령어 레지스터)           │  │
│  │  - AC (누산기)                    │  │
│  │  - MAR, MBR (메모리 접근용)       │  │
│  └──────────────────────────────────┘  │
└────────────────────────────────────────┘
```

### 3.2 주기억장치

| 유형 | 특성 | 용도 |
|------|------|------|
| RAM | 휘발성, 읽기/쓰기 | 실행 중 프로그램/데이터 |
| ROM | 비휘발성, 읽기 전용 | BIOS, 펌웨어 |
| Cache | 고속, 소용량 | CPU-메모리 속도 차이 해소 |

### 3.3 보조기억장치

| 유형 | 속도 | 용량 | 특징 |
|------|------|------|------|
| SSD | 빠름 | 중간 | 플래시 메모리, 무소음 |
| HDD | 느림 | 대용량 | 자기 디스크, 저렴 |
| USB | 중간 | 소용량 | 이동식 |

### 3.4 버스 시스템

```
┌───────────────────────────────────────────┐
│                데이터 버스                  │
│    (CPU ↔ 메모리 간 데이터 전송)           │
├───────────────────────────────────────────┤
│                주소 버스                   │
│    (메모리 주소 지정, 단방향)              │
├───────────────────────────────────────────┤
│                제어 버스                   │
│    (읽기/쓰기 제어 신호)                   │
└───────────────────────────────────────────┘
```

---

## 4. 소프트웨어 계층

### 계층 구조

```
┌─────────────────────────────────┐
│       응용 프로그램              │  웹 브라우저, 게임, 워드
├─────────────────────────────────┤
│       시스템 소프트웨어          │  컴파일러, 라이브러리
├─────────────────────────────────┤
│       운영체제 (OS)             │  Windows, Linux, macOS
├─────────────────────────────────┤
│       펌웨어 / BIOS             │  하드웨어 초기화
├─────────────────────────────────┤
│       하드웨어                   │  CPU, 메모리, 디스크
└─────────────────────────────────┘
```

### 명령어 실행 사이클

```
┌───────────────────────────────────────────────┐
│                                               │
│  ┌─────────┐   ┌─────────┐   ┌─────────┐     │
│  │  Fetch  │ → │ Decode  │ → │ Execute │     │
│  │ (인출)  │   │ (해독)  │   │ (실행)  │     │
│  └─────────┘   └─────────┘   └─────────┘     │
│       ↑                            │          │
│       └────────────────────────────┘          │
│                  반복                          │
└───────────────────────────────────────────────┘

1. Fetch:  PC가 가리키는 주소에서 명령어 가져옴
2. Decode: 명령어 해독, 필요한 연산 결정
3. Execute: ALU에서 연산 수행, 결과 저장
```

---

## 5. 성능 측정

### 주요 지표

| 지표 | 설명 | 단위 |
|------|------|------|
| 클럭 속도 | 초당 클럭 사이클 수 | Hz (GHz) |
| CPI | 명령어당 사이클 수 | cycles/instruction |
| MIPS | 초당 백만 명령어 수 | million instructions/sec |
| FLOPS | 초당 부동소수점 연산 | floating point ops/sec |

### 성능 계산 공식

```
CPU 시간 = 명령어 수 × CPI × 클럭 주기

         명령어 수 × CPI
CPU 시간 = ─────────────────
            클럭 속도

예시:
- 명령어 수: 10억 개
- CPI: 2
- 클럭 속도: 4GHz

CPU 시간 = (10^9 × 2) / (4 × 10^9) = 0.5초
```

### 암달의 법칙 (Amdahl's Law)

```
전체 성능 향상 = 1 / ((1 - P) + P/S)

P: 개선 가능한 부분의 비율
S: 해당 부분의 성능 향상 배수

예시: 프로그램의 80%를 2배 빠르게 개선
= 1 / ((1 - 0.8) + 0.8/2)
= 1 / (0.2 + 0.4)
= 1.67배 향상
```

---

## 6. 연습 문제

### 기초 문제

1. 폰 노이만 구조의 5대 구성요소는?

2. 다음 중 휘발성 메모리는?
   - (a) ROM
   - (b) RAM
   - (c) SSD
   - (d) HDD

3. CPU에서 명령어를 해독하는 부분은?

### 계산 문제

4. 클럭 속도가 3GHz이고 CPI가 1.5인 CPU에서 9억 개의 명령어를 실행하는 데 걸리는 시간은?

5. 프로그램의 70%가 병렬화 가능하고 4개의 코어로 실행할 때, 암달의 법칙에 따른 최대 성능 향상은?

### 심화 문제

6. 폰 노이만 병목을 해결하기 위한 방법 3가지를 설명하시오.

7. 하버드 구조와 폰 노이만 구조의 차이점을 설명하시오.

<details>
<summary>정답</summary>

1. 입력장치, 출력장치, 기억장치, 연산장치(ALU), 제어장치

2. (b) RAM

3. 제어 장치 (Control Unit)

4. (9×10^8 × 1.5) / (3×10^9) = 0.45초

5. 1 / ((1-0.7) + 0.7/4) = 1 / (0.3 + 0.175) = 2.1배

6. 캐시 메모리, 파이프라이닝, 다중 버스, 하버드 구조

7. 하버드 구조는 명령어와 데이터를 별도의 메모리에 저장하고 별도의 버스로 접근

</details>

---

## 다음 단계

- [02_Data_Representation_Basics.md](./02_Data_Representation_Basics.md) - 이진수와 진법 변환

---

## 참고 자료

- Computer Organization and Design (Patterson & Hennessy)
- [Crash Course: Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)
- [Nand2Tetris](https://www.nand2tetris.org/)

