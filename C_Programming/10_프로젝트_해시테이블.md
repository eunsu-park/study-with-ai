# í”„ë¡œì íŠ¸ 8: í•´ì‹œ í…Œì´ë¸”

## í•™ìŠµ ëª©í‘œ

ì´ í”„ë¡œì íŠ¸ë¥¼ í†µí•´ ë°°ìš°ëŠ” ë‚´ìš©:
- í•´ì‹œ í•¨ìˆ˜ì˜ ì›ë¦¬
- í•´ì‹œ í…Œì´ë¸” êµ¬ì¡°
- ì¶©ëŒ ì²˜ë¦¬ (ì²´ì´ë‹, ì˜¤í”ˆ ì–´ë“œë ˆì‹±)
- ì‹¤ì „ í™œìš©: ê°„ë‹¨í•œ ì‚¬ì „ í”„ë¡œê·¸ë¨

---

## í•´ì‹œ í…Œì´ë¸”ì´ë€?

### ê°œë…

í‚¤(Key)ë¥¼ í•´ì‹œ í•¨ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ **ì¸ë±ìŠ¤**ë¥¼ ìƒì„±í•˜ê³ , í•´ë‹¹ ìœ„ì¹˜ì— ê°’(Value)ì„ ì €ì¥í•©ë‹ˆë‹¤.

```
Key: "apple"
        â†“
Hash Function: hash("apple") = 3
        â†“
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   â”‚   â”‚   â”‚ğŸ â”‚   â”‚   â”‚   â”‚  â†’ Index 3ì— ì €ì¥
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3   4   5   6
```

### ì‹œê°„ ë³µì¡ë„

| ì—°ì‚° | í‰ê·  | ìµœì•… |
|------|------|------|
| ì‚½ì… | O(1) | O(n) |
| ê²€ìƒ‰ | O(1) | O(n) |
| ì‚­ì œ | O(1) | O(n) |

ìµœì•…ì˜ ê²½ìš°: ëª¨ë“  í‚¤ê°€ ê°™ì€ ì¸ë±ìŠ¤ë¡œ ì¶©ëŒí•  ë•Œ

---

## 1ë‹¨ê³„: í•´ì‹œ í•¨ìˆ˜ ì´í•´

### ì¢‹ì€ í•´ì‹œ í•¨ìˆ˜ì˜ ì¡°ê±´

1. **ê²°ì •ì **: ê°™ì€ ì…ë ¥ â†’ í•­ìƒ ê°™ì€ ì¶œë ¥
2. **ê· ì¼ ë¶„í¬**: ì¶œë ¥ì´ ê³ ë¥´ê²Œ ë¶„í¬
3. **ë¹ ë¥¸ ê³„ì‚°**: O(1) ì‹œê°„

### ë¬¸ìì—´ í•´ì‹œ í•¨ìˆ˜ë“¤

```c
// hash_functions.c
#include <stdio.h>
#include <string.h>

#define TABLE_SIZE 10

// 1. ë‹¨ìˆœ í•©ì‚° (ë‚˜ìœ ì˜ˆ)
unsigned int hash_simple(const char *key) {
    unsigned int hash = 0;
    while (*key) {
        hash += *key++;
    }
    return hash % TABLE_SIZE;
}

// 2. djb2 (Daniel J. Bernstein) - ì¶”ì²œ
unsigned int hash_djb2(const char *key) {
    unsigned int hash = 5381;
    int c;
    while ((c = *key++)) {
        hash = ((hash << 5) + hash) + c;  // hash * 33 + c
    }
    return hash % TABLE_SIZE;
}

// 3. sdbm
unsigned int hash_sdbm(const char *key) {
    unsigned int hash = 0;
    int c;
    while ((c = *key++)) {
        hash = c + (hash << 6) + (hash << 16) - hash;
    }
    return hash % TABLE_SIZE;
}

// 4. FNV-1a
unsigned int hash_fnv1a(const char *key) {
    unsigned int hash = 2166136261u;
    while (*key) {
        hash ^= (unsigned char)*key++;
        hash *= 16777619;
    }
    return hash % TABLE_SIZE;
}

int main(void) {
    const char *keys[] = {"apple", "banana", "cherry", "date", "elderberry"};
    int n = sizeof(keys) / sizeof(keys[0]);

    printf("=== í•´ì‹œ í•¨ìˆ˜ ë¹„êµ ===\n\n");
    printf("%-12s | simple | djb2 | sdbm | fnv1a\n", "Key");
    printf("-------------|--------|------|------|------\n");

    for (int i = 0; i < n; i++) {
        printf("%-12s | %6u | %4u | %4u | %5u\n",
               keys[i],
               hash_simple(keys[i]),
               hash_djb2(keys[i]),
               hash_sdbm(keys[i]),
               hash_fnv1a(keys[i]));
    }

    return 0;
}
```

---

## 2ë‹¨ê³„: ì²´ì´ë‹ (Separate Chaining)

ì¶©ëŒ ì‹œ ê°™ì€ ì¸ë±ìŠ¤ì— ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥í•©ë‹ˆë‹¤.

```
Index 3ì— ì¶©ëŒ ë°œìƒ:

â”Œâ”€â”€â”€â”
â”‚ 0 â”‚ â†’ NULL
â”œâ”€â”€â”€â”¤
â”‚ 1 â”‚ â†’ NULL
â”œâ”€â”€â”€â”¤
â”‚ 2 â”‚ â†’ NULL
â”œâ”€â”€â”€â”¤
â”‚ 3 â”‚ â†’ [apple] â†’ [apricot] â†’ NULL  (ì²´ì¸)
â”œâ”€â”€â”€â”¤
â”‚ 4 â”‚ â†’ NULL
â””â”€â”€â”€â”˜
```

### êµ¬í˜„

```c
// hash_chaining.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define TABLE_SIZE 10
#define KEY_SIZE 50
#define VALUE_SIZE 100

// ë…¸ë“œ (í‚¤-ê°’ ìŒ)
typedef struct Node {
    char key[KEY_SIZE];
    char value[VALUE_SIZE];
    struct Node *next;
} Node;

// í•´ì‹œ í…Œì´ë¸”
typedef struct {
    Node *buckets[TABLE_SIZE];
    int count;
} HashTable;

// í•´ì‹œ í•¨ìˆ˜ (djb2)
unsigned int hash(const char *key) {
    unsigned int hash = 5381;
    int c;
    while ((c = *key++)) {
        hash = ((hash << 5) + hash) + c;
    }
    return hash % TABLE_SIZE;
}

// ìƒì„±
HashTable* ht_create(void) {
    HashTable *ht = malloc(sizeof(HashTable));
    if (ht) {
        for (int i = 0; i < TABLE_SIZE; i++) {
            ht->buckets[i] = NULL;
        }
        ht->count = 0;
    }
    return ht;
}

// í•´ì œ
void ht_destroy(HashTable *ht) {
    for (int i = 0; i < TABLE_SIZE; i++) {
        Node *current = ht->buckets[i];
        while (current) {
            Node *next = current->next;
            free(current);
            current = next;
        }
    }
    free(ht);
}

// ì‚½ì…/ìˆ˜ì •
bool ht_set(HashTable *ht, const char *key, const char *value) {
    unsigned int index = hash(key);

    // ê¸°ì¡´ í‚¤ ì°¾ê¸°
    Node *current = ht->buckets[index];
    while (current) {
        if (strcmp(current->key, key) == 0) {
            // ê¸°ì¡´ í‚¤ â†’ ê°’ ì—…ë°ì´íŠ¸
            strncpy(current->value, value, VALUE_SIZE - 1);
            return true;
        }
        current = current->next;
    }

    // ìƒˆ ë…¸ë“œ ìƒì„±
    Node *node = malloc(sizeof(Node));
    if (!node) return false;

    strncpy(node->key, key, KEY_SIZE - 1);
    strncpy(node->value, value, VALUE_SIZE - 1);
    node->next = ht->buckets[index];
    ht->buckets[index] = node;
    ht->count++;

    return true;
}

// ê²€ìƒ‰
char* ht_get(HashTable *ht, const char *key) {
    unsigned int index = hash(key);

    Node *current = ht->buckets[index];
    while (current) {
        if (strcmp(current->key, key) == 0) {
            return current->value;
        }
        current = current->next;
    }

    return NULL;  // ì°¾ì§€ ëª»í•¨
}

// ì‚­ì œ
bool ht_delete(HashTable *ht, const char *key) {
    unsigned int index = hash(key);

    Node *current = ht->buckets[index];
    Node *prev = NULL;

    while (current) {
        if (strcmp(current->key, key) == 0) {
            if (prev) {
                prev->next = current->next;
            } else {
                ht->buckets[index] = current->next;
            }
            free(current);
            ht->count--;
            return true;
        }
        prev = current;
        current = current->next;
    }

    return false;  // ì°¾ì§€ ëª»í•¨
}

// ì¶œë ¥
void ht_print(HashTable *ht) {
    printf("\n=== Hash Table (count=%d) ===\n", ht->count);
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("[%d]: ", i);
        Node *current = ht->buckets[i];
        if (!current) {
            printf("(empty)");
        }
        while (current) {
            printf("(\"%s\": \"%s\")", current->key, current->value);
            if (current->next) printf(" -> ");
            current = current->next;
        }
        printf("\n");
    }
}

// í…ŒìŠ¤íŠ¸
int main(void) {
    HashTable *ht = ht_create();

    printf("=== ì²´ì´ë‹ í•´ì‹œ í…Œì´ë¸” ===\n");

    // ì‚½ì…
    ht_set(ht, "apple", "ì‚¬ê³¼");
    ht_set(ht, "banana", "ë°”ë‚˜ë‚˜");
    ht_set(ht, "cherry", "ì²´ë¦¬");
    ht_set(ht, "date", "ëŒ€ì¶”ì•¼ì");
    ht_set(ht, "elderberry", "ì—˜ë”ë² ë¦¬");

    ht_print(ht);

    // ê²€ìƒ‰
    printf("\nê²€ìƒ‰ í…ŒìŠ¤íŠ¸:\n");
    printf("apple: %s\n", ht_get(ht, "apple") ?: "(not found)");
    printf("grape: %s\n", ht_get(ht, "grape") ?: "(not found)");

    // ìˆ˜ì •
    printf("\nìˆ˜ì • í…ŒìŠ¤íŠ¸:\n");
    ht_set(ht, "apple", "ë§›ìˆëŠ” ì‚¬ê³¼");
    printf("apple: %s\n", ht_get(ht, "apple"));

    // ì‚­ì œ
    printf("\nì‚­ì œ í…ŒìŠ¤íŠ¸:\n");
    ht_delete(ht, "banana");
    ht_print(ht);

    ht_destroy(ht);
    return 0;
}
```

---

## 3ë‹¨ê³„: ì˜¤í”ˆ ì–´ë“œë ˆì‹± (Open Addressing)

ì¶©ëŒ ì‹œ ë‹¤ë¥¸ ë¹ˆ ìŠ¬ë¡¯ì„ ì°¾ì•„ ì €ì¥í•©ë‹ˆë‹¤.

### ì„ í˜• íƒì‚¬ (Linear Probing)

```
hash("apple") = 3, hash("apricot") = 3 (ì¶©ëŒ!)

ì‚½ì… "apple":
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   â”‚   â”‚   â”‚ğŸ â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3   4   5   6

ì‚½ì… "apricot" (ì¶©ëŒ â†’ ë‹¤ìŒ ìŠ¬ë¡¯):
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   â”‚   â”‚   â”‚ğŸ â”‚ğŸ‘ â”‚   â”‚   â”‚  â† Index 4ì— ì €ì¥
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3   4   5   6
```

### êµ¬í˜„

```c
// hash_linear_probing.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define TABLE_SIZE 10
#define KEY_SIZE 50
#define VALUE_SIZE 100

// ìŠ¬ë¡¯ ìƒíƒœ
typedef enum {
    EMPTY,      // ë¹„ì–´ìˆìŒ
    OCCUPIED,   // ì‚¬ìš© ì¤‘
    DELETED     // ì‚­ì œë¨ (íƒìƒ‰ ì‹œ ê³„ì† ì§„í–‰)
} SlotStatus;

// ìŠ¬ë¡¯
typedef struct {
    char key[KEY_SIZE];
    char value[VALUE_SIZE];
    SlotStatus status;
} Slot;

// í•´ì‹œ í…Œì´ë¸”
typedef struct {
    Slot slots[TABLE_SIZE];
    int count;
} HashTable;

unsigned int hash(const char *key) {
    unsigned int hash = 5381;
    int c;
    while ((c = *key++)) {
        hash = ((hash << 5) + hash) + c;
    }
    return hash % TABLE_SIZE;
}

HashTable* ht_create(void) {
    HashTable *ht = malloc(sizeof(HashTable));
    if (ht) {
        for (int i = 0; i < TABLE_SIZE; i++) {
            ht->slots[i].status = EMPTY;
        }
        ht->count = 0;
    }
    return ht;
}

void ht_destroy(HashTable *ht) {
    free(ht);
}

// ì‚½ì…
bool ht_set(HashTable *ht, const char *key, const char *value) {
    if (ht->count >= TABLE_SIZE) {
        printf("Hash table is full!\n");
        return false;
    }

    unsigned int index = hash(key);
    unsigned int original_index = index;

    // ì„ í˜• íƒì‚¬
    do {
        // ë¹ˆ ìŠ¬ë¡¯ ë˜ëŠ” ê°™ì€ í‚¤
        if (ht->slots[index].status != OCCUPIED ||
            strcmp(ht->slots[index].key, key) == 0) {

            if (ht->slots[index].status != OCCUPIED) {
                ht->count++;
            }

            strncpy(ht->slots[index].key, key, KEY_SIZE - 1);
            strncpy(ht->slots[index].value, value, VALUE_SIZE - 1);
            ht->slots[index].status = OCCUPIED;
            return true;
        }

        index = (index + 1) % TABLE_SIZE;  // ë‹¤ìŒ ìŠ¬ë¡¯
    } while (index != original_index);

    return false;
}

// ê²€ìƒ‰
char* ht_get(HashTable *ht, const char *key) {
    unsigned int index = hash(key);
    unsigned int original_index = index;

    do {
        if (ht->slots[index].status == EMPTY) {
            return NULL;  // ì°¾ì§€ ëª»í•¨
        }

        if (ht->slots[index].status == OCCUPIED &&
            strcmp(ht->slots[index].key, key) == 0) {
            return ht->slots[index].value;
        }

        index = (index + 1) % TABLE_SIZE;
    } while (index != original_index);

    return NULL;
}

// ì‚­ì œ
bool ht_delete(HashTable *ht, const char *key) {
    unsigned int index = hash(key);
    unsigned int original_index = index;

    do {
        if (ht->slots[index].status == EMPTY) {
            return false;
        }

        if (ht->slots[index].status == OCCUPIED &&
            strcmp(ht->slots[index].key, key) == 0) {
            ht->slots[index].status = DELETED;  // EMPTYê°€ ì•„ë‹Œ DELETED
            ht->count--;
            return true;
        }

        index = (index + 1) % TABLE_SIZE;
    } while (index != original_index);

    return false;
}

void ht_print(HashTable *ht) {
    printf("\n=== Hash Table (count=%d) ===\n", ht->count);
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("[%d]: ", i);
        switch (ht->slots[i].status) {
            case EMPTY:
                printf("(empty)\n");
                break;
            case DELETED:
                printf("(deleted)\n");
                break;
            case OCCUPIED:
                printf("\"%s\": \"%s\"\n",
                       ht->slots[i].key, ht->slots[i].value);
                break;
        }
    }
}

int main(void) {
    HashTable *ht = ht_create();

    printf("=== ì„ í˜• íƒì‚¬ í•´ì‹œ í…Œì´ë¸” ===\n");

    ht_set(ht, "apple", "ì‚¬ê³¼");
    ht_set(ht, "banana", "ë°”ë‚˜ë‚˜");
    ht_set(ht, "cherry", "ì²´ë¦¬");

    ht_print(ht);

    printf("\nê²€ìƒ‰: apple = %s\n", ht_get(ht, "apple") ?: "(not found)");

    printf("\nì‚­ì œ: banana\n");
    ht_delete(ht, "banana");
    ht_print(ht);

    ht_destroy(ht);
    return 0;
}
```

---

## 4ë‹¨ê³„: ì‹¤ì „ - ê°„ë‹¨í•œ ì‚¬ì „ í”„ë¡œê·¸ë¨

```c
// dictionary.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define TABLE_SIZE 1000
#define KEY_SIZE 100
#define VALUE_SIZE 500

typedef struct Node {
    char word[KEY_SIZE];
    char meaning[VALUE_SIZE];
    struct Node *next;
} Node;

typedef struct {
    Node *buckets[TABLE_SIZE];
    int count;
} Dictionary;

unsigned int hash(const char *key) {
    unsigned int hash = 5381;
    while (*key) {
        hash = ((hash << 5) + hash) + tolower(*key++);
    }
    return hash % TABLE_SIZE;
}

Dictionary* dict_create(void) {
    Dictionary *dict = calloc(1, sizeof(Dictionary));
    return dict;
}

void dict_destroy(Dictionary *dict) {
    for (int i = 0; i < TABLE_SIZE; i++) {
        Node *current = dict->buckets[i];
        while (current) {
            Node *next = current->next;
            free(current);
            current = next;
        }
    }
    free(dict);
}

void dict_add(Dictionary *dict, const char *word, const char *meaning) {
    unsigned int index = hash(word);

    // ê¸°ì¡´ ë‹¨ì–´ í™•ì¸
    Node *current = dict->buckets[index];
    while (current) {
        if (strcasecmp(current->word, word) == 0) {
            strncpy(current->meaning, meaning, VALUE_SIZE - 1);
            printf("'%s' ì—…ë°ì´íŠ¸ë¨\n", word);
            return;
        }
        current = current->next;
    }

    // ìƒˆ ë‹¨ì–´ ì¶”ê°€
    Node *node = malloc(sizeof(Node));
    strncpy(node->word, word, KEY_SIZE - 1);
    strncpy(node->meaning, meaning, VALUE_SIZE - 1);
    node->next = dict->buckets[index];
    dict->buckets[index] = node;
    dict->count++;
    printf("'%s' ì¶”ê°€ë¨\n", word);
}

char* dict_search(Dictionary *dict, const char *word) {
    unsigned int index = hash(word);

    Node *current = dict->buckets[index];
    while (current) {
        if (strcasecmp(current->word, word) == 0) {
            return current->meaning;
        }
        current = current->next;
    }
    return NULL;
}

void dict_delete(Dictionary *dict, const char *word) {
    unsigned int index = hash(word);

    Node *current = dict->buckets[index];
    Node *prev = NULL;

    while (current) {
        if (strcasecmp(current->word, word) == 0) {
            if (prev) {
                prev->next = current->next;
            } else {
                dict->buckets[index] = current->next;
            }
            free(current);
            dict->count--;
            printf("'%s' ì‚­ì œë¨\n", word);
            return;
        }
        prev = current;
        current = current->next;
    }
    printf("'%s'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤\n", word);
}

void dict_list(Dictionary *dict) {
    printf("\n=== ì‚¬ì „ ëª©ë¡ (ì´ %dê°œ) ===\n", dict->count);
    for (int i = 0; i < TABLE_SIZE; i++) {
        Node *current = dict->buckets[i];
        while (current) {
            printf("  %s: %s\n", current->word, current->meaning);
            current = current->next;
        }
    }
}

void print_menu(void) {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘      ğŸ“– ê°„ë‹¨í•œ ì‚¬ì „        â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘  1. ë‹¨ì–´ ì¶”ê°€              â•‘\n");
    printf("â•‘  2. ë‹¨ì–´ ê²€ìƒ‰              â•‘\n");
    printf("â•‘  3. ë‹¨ì–´ ì‚­ì œ              â•‘\n");
    printf("â•‘  4. ì „ì²´ ëª©ë¡              â•‘\n");
    printf("â•‘  0. ì¢…ë£Œ                   â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

void clear_input(void) {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

int main(void) {
    Dictionary *dict = dict_create();
    int choice;
    char word[KEY_SIZE];
    char meaning[VALUE_SIZE];

    // ìƒ˜í”Œ ë°ì´í„°
    dict_add(dict, "apple", "ì‚¬ê³¼; ê³¼ì¼ì˜ ì¼ì¢…");
    dict_add(dict, "book", "ì±…; ì¸ì‡„ë¬¼ì„ ì œë³¸í•œ ê²ƒ");
    dict_add(dict, "computer", "ì»´í“¨í„°; ì „ì ê³„ì‚°ê¸°");

    while (1) {
        print_menu();
        printf("ì„ íƒ: ");
        scanf("%d", &choice);
        clear_input();

        switch (choice) {
            case 1:
                printf("ë‹¨ì–´: ");
                fgets(word, KEY_SIZE, stdin);
                word[strcspn(word, "\n")] = '\0';

                printf("ëœ»: ");
                fgets(meaning, VALUE_SIZE, stdin);
                meaning[strcspn(meaning, "\n")] = '\0';

                dict_add(dict, word, meaning);
                break;

            case 2:
                printf("ê²€ìƒ‰í•  ë‹¨ì–´: ");
                fgets(word, KEY_SIZE, stdin);
                word[strcspn(word, "\n")] = '\0';

                char *result = dict_search(dict, word);
                if (result) {
                    printf("\n  %s: %s\n", word, result);
                } else {
                    printf("\n  '%s'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤\n", word);
                }
                break;

            case 3:
                printf("ì‚­ì œí•  ë‹¨ì–´: ");
                fgets(word, KEY_SIZE, stdin);
                word[strcspn(word, "\n")] = '\0';

                dict_delete(dict, word);
                break;

            case 4:
                dict_list(dict);
                break;

            case 0:
                printf("ì‚¬ì „ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n");
                dict_destroy(dict);
                return 0;

            default:
                printf("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.\n");
        }
    }

    return 0;
}
```

---

## ì»´íŒŒì¼ ë° ì‹¤í–‰

```bash
gcc -Wall -std=c11 hash_chaining.c -o hash_chaining
gcc -Wall -std=c11 dictionary.c -o dictionary
./dictionary
```

---

## ë°°ìš´ ë‚´ìš© ì •ë¦¬

| ê°œë… | ì„¤ëª… |
|------|------|
| í•´ì‹œ í•¨ìˆ˜ | í‚¤ë¥¼ ì¸ë±ìŠ¤ë¡œ ë³€í™˜ |
| ì¶©ëŒ | ë‹¤ë¥¸ í‚¤ê°€ ê°™ì€ ì¸ë±ìŠ¤ |
| ì²´ì´ë‹ | ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì¶©ëŒ ì²˜ë¦¬ |
| ì˜¤í”ˆ ì–´ë“œë ˆì‹± | ë¹ˆ ìŠ¬ë¡¯ íƒì‚¬ë¡œ ì¶©ëŒ ì²˜ë¦¬ |
| ë¡œë“œ íŒ©í„° | count / table_size (0.7 ì´í•˜ ê¶Œì¥) |

### ì²´ì´ë‹ vs ì˜¤í”ˆ ì–´ë“œë ˆì‹±

| ë¹„êµ | ì²´ì´ë‹ | ì˜¤í”ˆ ì–´ë“œë ˆì‹± |
|------|--------|---------------|
| ë©”ëª¨ë¦¬ | ë™ì  í• ë‹¹ | ê³ ì • í¬ê¸° |
| ì‚­ì œ | ê°„ë‹¨ | DELETED í‘œì‹œ í•„ìš” |
| ìºì‹œ | ë¶ˆë¦¬ | ìœ ë¦¬ |
| ë¡œë“œ íŒ©í„° | >1 ê°€ëŠ¥ | <1 í•„ìˆ˜ |

---

## ì—°ìŠµ ë¬¸ì œ

1. **í¬ê¸° ì¡°ì ˆ**: ë¡œë“œ íŒ©í„°ê°€ 0.7 ë„˜ìœ¼ë©´ í…Œì´ë¸” í¬ê¸° 2ë°°ë¡œ í™•ì¥

2. **íŒŒì¼ ì €ì¥**: ì‚¬ì „ ë°ì´í„°ë¥¼ íŒŒì¼ë¡œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°

3. **ì´ì¤‘ í•´ì‹±**: ì¶©ëŒ ì‹œ ë‘ ë²ˆì§¸ í•´ì‹œ í•¨ìˆ˜ë¡œ íƒì‚¬ ê°„ê²© ê²°ì •

---

## ë‹¤ìŒ ë‹¨ê³„

[10_í”„ë¡œì íŠ¸_ë±€ê²Œì„.md](./10_í”„ë¡œì íŠ¸_ë±€ê²Œì„.md) â†’ í„°ë¯¸ë„ ê²Œì„ì„ ë§Œë“¤ì–´ë´…ì‹œë‹¤!
