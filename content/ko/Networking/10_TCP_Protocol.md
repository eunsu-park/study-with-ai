# TCP 프로토콜

## 개요

이 문서에서는 TCP(Transmission Control Protocol)의 핵심 개념을 다룹니다. 연결 지향적이고 신뢰성 있는 데이터 전송을 보장하는 TCP의 동작 원리, 헤더 구조, 흐름 제어, 혼잡 제어 메커니즘을 학습합니다.

**난이도**: ⭐⭐⭐
**예상 학습 시간**: 3-4시간
**선수 지식**: [09_Routing_Protocols.md](./09_Routing_Protocols.md)

---

## 목차

1. [TCP의 특징](#1-tcp의-특징)
2. [TCP 헤더 구조](#2-tcp-헤더-구조)
3. [3-Way Handshake](#3-3-way-handshake)
4. [4-Way Handshake](#4-4-way-handshake)
5. [시퀀스 번호와 ACK](#5-시퀀스-번호와-ack)
6. [흐름 제어](#6-흐름-제어)
7. [혼잡 제어](#7-혼잡-제어)
8. [연습 문제](#8-연습-문제)
9. [다음 단계](#9-다음-단계)
10. [참고 자료](#10-참고-자료)

---

## 1. TCP의 특징

### 1.1 TCP 기본 특성

```
┌─────────────────────────────────────────────────────────────────┐
│                       TCP 특징                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 연결 지향 (Connection-Oriented)                             │
│     - 데이터 전송 전 연결 설정 필요 (3-way handshake)           │
│     - 전송 완료 후 연결 해제 (4-way handshake)                  │
│                                                                  │
│  2. 신뢰성 (Reliability)                                        │
│     - 데이터 전달 보장                                          │
│     - 순서 보장                                                 │
│     - 오류 감지 및 재전송                                       │
│                                                                  │
│  3. 흐름 제어 (Flow Control)                                    │
│     - 수신자의 처리 속도에 맞춰 전송                            │
│     - 슬라이딩 윈도우 사용                                      │
│                                                                  │
│  4. 혼잡 제어 (Congestion Control)                              │
│     - 네트워크 혼잡 상황 대응                                   │
│     - Slow Start, Congestion Avoidance 등                       │
│                                                                  │
│  5. 전이중 통신 (Full-Duplex)                                   │
│     - 양방향 동시 데이터 전송 가능                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 TCP vs UDP 간단 비교

| 특성 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향 | 비연결 |
| 신뢰성 | 신뢰성 보장 | 비신뢰성 |
| 순서 | 순서 보장 | 순서 미보장 |
| 속도 | 상대적 느림 | 빠름 |
| 헤더 크기 | 20-60 바이트 | 8 바이트 |
| 용도 | 웹, 이메일, 파일 전송 | 스트리밍, DNS, 게임 |

### 1.3 TCP 세그먼트

```
TCP 데이터 캡슐화

┌─────────────────────────────────────────────────────────────────┐
│ Application Layer                                               │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │                         Data                                 │ │
│ └─────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Transport Layer (TCP)                                           │
│ ┌──────────────┬──────────────────────────────────────────────┐ │
│ │  TCP Header  │                    Data                       │ │
│ │   (20-60B)   │                (Segment)                      │ │
│ └──────────────┴──────────────────────────────────────────────┘ │
│                      TCP Segment                                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Network Layer (IP)                                              │
│ ┌──────────────┬──────────────────────────────────────────────┐ │
│ │  IP Header   │              TCP Segment                      │ │
│ │   (20-60B)   │                                               │ │
│ └──────────────┴──────────────────────────────────────────────┘ │
│                       IP Packet                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. TCP 헤더 구조

### 2.1 TCP 헤더 형식

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |       |C|E|U|A|P|R|S|F|                               |
| Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
|       |       |R|E|G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if any)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 2.2 헤더 필드 설명

| 필드 | 크기 | 설명 |
|------|------|------|
| Source Port | 16 bits | 송신자 포트 번호 (0-65535) |
| Destination Port | 16 bits | 수신자 포트 번호 (0-65535) |
| Sequence Number | 32 bits | 세그먼트 데이터의 첫 번째 바이트 번호 |
| Acknowledgment Number | 32 bits | 다음에 받을 것으로 기대하는 바이트 번호 |
| Data Offset | 4 bits | TCP 헤더 길이 (4바이트 단위) |
| Reserved | 4 bits | 예약 (0으로 설정) |
| Flags | 8 bits | 제어 플래그 (CWR, ECE, URG, ACK, PSH, RST, SYN, FIN) |
| Window | 16 bits | 수신 윈도우 크기 (흐름 제어) |
| Checksum | 16 bits | 오류 검출용 체크섬 |
| Urgent Pointer | 16 bits | 긴급 데이터 위치 (URG 플래그 설정 시) |
| Options | 0-40 bytes | 추가 옵션 (MSS, Window Scale 등) |

### 2.3 TCP 플래그

```
┌─────────────────────────────────────────────────────────────────┐
│                       TCP 플래그                                 │
├─────────┬───────────────────────────────────────────────────────┤
│ CWR     │ Congestion Window Reduced - 혼잡 윈도우 축소 알림     │
│ ECE     │ ECN-Echo - 명시적 혼잡 알림                           │
│ URG     │ Urgent - 긴급 데이터 존재                             │
│ ACK     │ Acknowledgment - 확인 응답 유효                       │
│ PSH     │ Push - 버퍼링 없이 즉시 전달                          │
│ RST     │ Reset - 연결 강제 종료                                │
│ SYN     │ Synchronize - 연결 요청 (시퀀스 번호 동기화)          │
│ FIN     │ Finish - 연결 종료 요청                               │
└─────────┴───────────────────────────────────────────────────────┘
```

### 2.4 주요 TCP 옵션

| 옵션 | Kind | 설명 |
|------|------|------|
| MSS | 2 | Maximum Segment Size (일반적으로 1460 bytes) |
| Window Scale | 3 | 윈도우 크기 확장 (최대 1GB까지) |
| SACK Permitted | 4 | Selective ACK 지원 여부 |
| SACK | 5 | 수신된 세그먼트 범위 |
| Timestamps | 8 | RTT 측정 및 PAWS |
| NOP | 1 | 패딩용 (No Operation) |

---

## 3. 3-Way Handshake

### 3.1 연결 설정 과정

TCP 연결은 3-way handshake를 통해 설정됩니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    3-Way Handshake                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│     클라이언트                           서버                   │
│         │                                  │                    │
│         │  Step 1: SYN                     │                    │
│         │  ─────────────────────────────►  │                    │
│         │  SYN=1, Seq=100                  │                    │
│  CLOSED │                                  │ LISTEN             │
│    ↓    │                                  │    ↓               │
│ SYN_SENT│  Step 2: SYN-ACK                 │ SYN_RECEIVED       │
│         │  ◄─────────────────────────────  │                    │
│         │  SYN=1, ACK=1, Seq=300, Ack=101  │                    │
│    ↓    │                                  │                    │
│ ESTABLISHED Step 3: ACK                    │                    │
│         │  ─────────────────────────────►  │                    │
│         │  ACK=1, Seq=101, Ack=301         │                    │
│         │                                  │ ESTABLISHED        │
│         │                                  │                    │
│         │        연결 수립 완료            │                    │
│         │  ◄═════════════════════════════► │                    │
│         │         Data Transfer            │                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 각 단계 상세

**Step 1: SYN (Synchronize)**
```
클라이언트 → 서버

TCP Header:
  Source Port: 50000 (임의)
  Destination Port: 80 (HTTP)
  Sequence Number: 100 (ISN - Initial Sequence Number)
  Acknowledgment: 0
  Flags: SYN=1
  Window: 65535
  Options: MSS=1460, Window Scale=7

의미: "연결하고 싶습니다. 내 시퀀스 번호는 100부터 시작합니다."
```

**Step 2: SYN-ACK**
```
서버 → 클라이언트

TCP Header:
  Source Port: 80
  Destination Port: 50000
  Sequence Number: 300 (서버의 ISN)
  Acknowledgment: 101 (클라이언트 Seq + 1)
  Flags: SYN=1, ACK=1
  Window: 65535
  Options: MSS=1460, Window Scale=7

의미: "연결 요청을 받았습니다. 101번 바이트를 기다립니다.
       내 시퀀스 번호는 300부터 시작합니다."
```

**Step 3: ACK**
```
클라이언트 → 서버

TCP Header:
  Source Port: 50000
  Destination Port: 80
  Sequence Number: 101
  Acknowledgment: 301 (서버 Seq + 1)
  Flags: ACK=1
  Window: 65535

의미: "서버의 응답을 받았습니다. 301번 바이트를 기다립니다.
       이제 데이터를 주고받을 수 있습니다."
```

### 3.3 ISN (Initial Sequence Number)

```
ISN이 랜덤인 이유:

1. 보안
   - 예측 가능한 ISN은 TCP 세션 하이재킹 취약
   - 랜덤 ISN으로 공격 난이도 증가

2. 이전 연결과 구분
   - 동일 소켓(IP:Port 쌍)의 이전 연결 패킷과 혼동 방지
   - TIME_WAIT 상태와 연관

ISN 생성 예시:
  현대 운영체제: 안전한 난수 생성기(CSPRNG) 사용
  과거: 시간 기반 카운터 (4마이크로초마다 1 증가)
```

### 3.4 TCP 상태 전이 (연결 설정)

```
클라이언트 상태 전이:
CLOSED → SYN_SENT → ESTABLISHED

서버 상태 전이:
CLOSED → LISTEN → SYN_RECEIVED → ESTABLISHED
```

---

## 4. 4-Way Handshake

### 4.1 연결 종료 과정

TCP 연결은 4-way handshake를 통해 정상적으로 종료됩니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                    4-Way Handshake                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   클라이언트 (능동적 종료)         서버 (수동적 종료)           │
│         │                                  │                    │
│ ESTABLISHED                          ESTABLISHED               │
│         │                                  │                    │
│         │  Step 1: FIN                     │                    │
│         │  ─────────────────────────────►  │                    │
│         │  FIN=1, Seq=100                  │                    │
│ FIN_WAIT_1                                 │                    │
│         │                                  │ CLOSE_WAIT         │
│         │  Step 2: ACK                     │                    │
│         │  ◄─────────────────────────────  │                    │
│         │  ACK=1, Ack=101                  │                    │
│ FIN_WAIT_2                                 │                    │
│         │                                  │ (남은 데이터 전송)  │
│         │                                  │                    │
│         │  Step 3: FIN                     │                    │
│         │  ◄─────────────────────────────  │                    │
│         │  FIN=1, Seq=300                  │ LAST_ACK           │
│ TIME_WAIT                                  │                    │
│         │  Step 4: ACK                     │                    │
│         │  ─────────────────────────────►  │                    │
│         │  ACK=1, Ack=301                  │                    │
│         │                                  │ CLOSED             │
│  (2MSL 대기)                               │                    │
│ CLOSED                                                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 각 단계 상세

| 단계 | 발신자 | 플래그 | 설명 |
|------|--------|--------|------|
| 1 | 클라이언트 | FIN | "보낼 데이터 없음. 연결 종료 요청" |
| 2 | 서버 | ACK | "FIN 수신 확인. 아직 보낼 데이터 있을 수 있음" |
| 3 | 서버 | FIN | "나도 보낼 데이터 없음. 연결 종료 동의" |
| 4 | 클라이언트 | ACK | "FIN 수신 확인. 연결 종료 완료" |

### 4.3 Half-Close

TCP는 half-close를 지원합니다. 한쪽에서 FIN을 보내도 다른 쪽은 계속 데이터를 보낼 수 있습니다.

```
Half-Close 시나리오

클라이언트           서버
    │                  │
    │── FIN ─────────►│  클라이언트: "더 보낼 데이터 없음"
    │                  │
    │◄──── ACK ───────│  서버: "알겠음"
    │                  │
    │◄──── Data ──────│  서버: 남은 데이터 계속 전송
    │◄──── Data ──────│
    │                  │
    │── ACK ─────────►│
    │                  │
    │◄──── FIN ───────│  서버: "나도 다 보냄"
    │                  │
    │── ACK ─────────►│  연결 종료
    │                  │
```

### 4.4 TIME_WAIT 상태

```
TIME_WAIT의 목적:

1. 지연 패킷 처리
   - 네트워크에 남아있는 이전 연결의 패킷 소멸 대기
   - 새 연결에서 혼란 방지

2. 마지막 ACK 손실 대비
   - 서버가 마지막 ACK를 못 받으면 FIN 재전송
   - 클라이언트가 TIME_WAIT 상태면 재응답 가능

TIME_WAIT 지속 시간: 2 × MSL (Maximum Segment Lifetime)
  - MSL: 일반적으로 30초 또는 2분
  - TIME_WAIT: 1분 ~ 4분

┌─────────────────────────────────────────────────────────────────┐
│  TIME_WAIT 문제                                                 │
├─────────────────────────────────────────────────────────────────┤
│  - 대량의 단기 연결 시 포트 고갈 가능                          │
│  - 해결책:                                                      │
│    1. SO_REUSEADDR 소켓 옵션 사용                               │
│    2. tcp_tw_reuse 커널 파라미터 (Linux)                        │
│    3. 커넥션 풀링 사용                                          │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5 TCP 상태 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                 TCP 상태 다이어그램 (간략)                       │
└─────────────────────────────────────────────────────────────────┘

                              CLOSED
                                │
              ┌─────────────────┼─────────────────┐
              │ 능동적 열기     │ 수동적 열기     │
              ▼                 ▼                 │
          SYN_SENT ──────► LISTEN                │
              │                 │                 │
              │  SYN 수신       │ SYN 수신        │
              ▼                 ▼                 │
          ◄──────────── SYN_RCVD ─────────►      │
                              │                   │
                    ACK 수신  │                   │
                              ▼                   │
                        ESTABLISHED               │
                              │                   │
              ┌───────────────┴───────────────┐   │
              │ 능동적 종료    수동적 종료    │   │
              ▼                               ▼   │
          FIN_WAIT_1                    CLOSE_WAIT │
              │                               │   │
              ▼                               ▼   │
          FIN_WAIT_2                     LAST_ACK │
              │                               │   │
              ▼                               │   │
          TIME_WAIT ─────────────────────────►│   │
              │                                   │
              └─── 2MSL ──────────────────────────┘
                              │
                              ▼
                           CLOSED
```

---

## 5. 시퀀스 번호와 ACK

### 5.1 시퀀스 번호의 역할

```
시퀀스 번호 동작

클라이언트                               서버
    │                                      │
    │── Seq=1000, 1000 bytes ────────────►│
    │       (1000-1999)                    │
    │                                      │
    │◄─────────────────── ACK=2000 ───────│
    │   "2000번 바이트부터 보내주세요"     │
    │                                      │
    │── Seq=2000, 1000 bytes ────────────►│
    │       (2000-2999)                    │
    │                                      │
    │◄─────────────────── ACK=3000 ───────│
    │                                      │

시퀀스 번호 = 이 세그먼트의 첫 번째 데이터 바이트 번호
ACK 번호 = 다음에 받기를 기대하는 바이트 번호
```

### 5.2 누적 확인 응답 (Cumulative ACK)

```
누적 ACK 동작

송신자                                   수신자
    │                                      │
    │── Seq=1000, 500 bytes ─────────────►│
    │── Seq=1500, 500 bytes ─────────────►│
    │── Seq=2000, 500 bytes ─────────────►│
    │                                      │
    │◄────────────────────── ACK=2500 ────│
    │                                      │
    │  하나의 ACK로 3개 세그먼트 모두 확인 │
    │                                      │

장점:
- ACK 패킷 수 감소
- 네트워크 효율성 향상

단점:
- 중간 패킷 손실 시 이후 패킷도 재전송
  (SACK으로 해결)
```

### 5.3 SACK (Selective Acknowledgment)

```
SACK 동작

송신자                                   수신자
    │                                      │
    │── Seq=1000, 500B ─────────────────►│ ✓
    │── Seq=1500, 500B ────────────X     │ (손실)
    │── Seq=2000, 500B ─────────────────►│ ✓
    │── Seq=2500, 500B ─────────────────►│ ✓
    │                                      │
    │◄──── ACK=1500, SACK=2000-3000 ─────│
    │      "1500 빠졌는데, 2000-3000은 받음"
    │                                      │
    │── Seq=1500, 500B ─────────────────►│ (재전송)
    │                                      │
    │◄────────────────────── ACK=3000 ────│
    │                                      │

SACK 장점:
- 손실된 세그먼트만 선택적 재전송
- 불필요한 재전송 방지
- 고속 네트워크에서 효율적
```

### 5.4 재전송 타이머 (RTO)

```
RTO (Retransmission Timeout) 계산

1. RTT (Round Trip Time) 측정
   - 세그먼트 전송부터 ACK 수신까지 시간

2. SRTT (Smoothed RTT) 계산
   SRTT = (1 - α) × SRTT + α × RTT
   (α = 1/8, 일반적)

3. RTTVAR (RTT Variance) 계산
   RTTVAR = (1 - β) × RTTVAR + β × |SRTT - RTT|
   (β = 1/4, 일반적)

4. RTO 계산
   RTO = SRTT + max(G, 4 × RTTVAR)
   (G = 클럭 granularity)

예시:
  측정된 RTT: 100ms, 120ms, 90ms, 110ms
  SRTT ≈ 105ms
  RTTVAR ≈ 10ms
  RTO = 105 + 4 × 10 = 145ms
```

---

## 6. 흐름 제어

### 6.1 슬라이딩 윈도우

```
슬라이딩 윈도우 개념

송신 버퍼:
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │10 │11 │12 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
│ACK됨│    윈도우 (전송 가능)    │   아직 전송 불가   │
│     │◄────── Window=5 ───────►│                    │

수신 윈도우 크기에 따라 전송량 조절:

Window = 5000:
┌──────────────────────────────────────────────────┐
│     최대 5000 bytes까지 ACK 없이 전송 가능       │
└──────────────────────────────────────────────────┘

Window = 0 (Zero Window):
┌──────────────────────────────────────────────────┐
│     전송 중지! 수신자 버퍼 가득 참               │
│     Window Probe로 주기적 확인                    │
└──────────────────────────────────────────────────┘
```

### 6.2 윈도우 크기 조절

```
윈도우 크기 변화

송신자                               수신자
    │                                  │ rcvbuf=4000
    │── 1000B ────────────────────────►│ Window=3000
    │── 1000B ────────────────────────►│ Window=2000
    │── 1000B ────────────────────────►│ Window=1000
    │                                  │
    │◄─── ACK, Window=0 (버퍼 풀) ─────│
    │                                  │
    │     (애플리케이션이 데이터 읽음)  │
    │                                  │
    │◄─── ACK, Window=4000 ────────────│
    │                                  │
    │── 1000B ────────────────────────►│
    │── 1000B ────────────────────────►│
```

### 6.3 Window Scale 옵션

```
기본 윈도우 크기: 16비트 = 최대 65,535 bytes

고속 네트워크에서 부족:
  - 100Mbps, RTT 100ms → BDP = 100 × 0.1 / 8 = 1.25MB 필요
  - 1Gbps, RTT 100ms → BDP = 12.5MB 필요

Window Scale 옵션:
  - 3-way handshake에서 협상
  - 윈도우 값을 왼쪽으로 시프트
  - 최대 스케일: 14 (윈도우 최대 약 1GB)

예시:
  Window = 65535, Scale = 7
  실제 윈도우 = 65535 × 2^7 = 65535 × 128 = 8,388,480 bytes (약 8MB)
```

### 6.4 Silly Window Syndrome 방지

```
문제: 작은 세그먼트 다수 전송 (비효율적)

송신측 해결: Nagle 알고리즘
┌─────────────────────────────────────────────────────────────────┐
│  작은 데이터가 있을 때:                                         │
│  1. 미전송 데이터가 없으면 즉시 전송                            │
│  2. 미전송 데이터가 있으면 MSS만큼 모이거나 ACK 올 때까지 대기   │
└─────────────────────────────────────────────────────────────────┘

수신측 해결: Delayed ACK + Clark's Solution
┌─────────────────────────────────────────────────────────────────┐
│  1. ACK를 즉시 보내지 않고 200ms 대기                           │
│  2. 윈도우 업데이트는 MSS 이상 또는 버퍼의 50% 이상일 때만      │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 혼잡 제어

### 7.1 혼잡 제어 개요

```
┌─────────────────────────────────────────────────────────────────┐
│                     TCP 혼잡 제어                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  목적: 네트워크 혼잡을 감지하고 전송률을 조절                   │
│                                                                  │
│  핵심 변수:                                                     │
│  - cwnd (Congestion Window): 송신자가 결정하는 윈도우           │
│  - rwnd (Receive Window): 수신자가 광고하는 윈도우              │
│  - 실제 전송 가능량 = min(cwnd, rwnd)                           │
│                                                                  │
│  ssthresh (Slow Start Threshold):                               │
│  - Slow Start와 Congestion Avoidance의 경계                     │
│  - 혼잡 발생 시 조정                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 Slow Start

```
Slow Start 동작

                cwnd 변화
               │
       64 MSS  ┤                              * (혼잡 발생)
               │                            *
       32 MSS  ┤                          *
               │                        *
       16 MSS  ┤                      *
               │                    *
        8 MSS  ┤                  *
               │                *
        4 MSS  ┤              *
               │            *
        2 MSS  ┤          *
               │        *
        1 MSS  ┤      *
               │
               └──────────────────────────────────── RTT
                    1   2   3   4   5   6

규칙:
- 초기 cwnd = 1 MSS (또는 IW=10 MSS, 최신 구현)
- 각 ACK마다 cwnd += 1 MSS
- 결과: RTT마다 cwnd 2배 증가 (지수적 증가)
- ssthresh 도달 시 Congestion Avoidance로 전환
```

### 7.3 Congestion Avoidance

```
Congestion Avoidance 동작

                cwnd 변화
               │
               │  ssthresh                    * (혼잡 발생)
        16 MSS ┼─────────────*──────────*──*
               │           *   *       *
               │         *      *    *
               │       *          *
               │     *       선형 증가 (AIMD)
               │   *
               │ *  Slow Start (지수)
               │*
               │
               └──────────────────────────────────── RTT

규칙:
- cwnd >= ssthresh일 때 동작
- 각 RTT마다 cwnd += 1 MSS (또는 cwnd += MSS/cwnd per ACK)
- 선형 증가 (Additive Increase)
```

### 7.4 혼잡 감지와 대응

```
혼잡 감지 방법:

1. 타임아웃 (RTO 만료)
   - 심각한 혼잡으로 판단
   - ssthresh = cwnd / 2
   - cwnd = 1 MSS
   - Slow Start 재시작

2. 중복 ACK 3개 (Fast Retransmit)
   - 경미한 혼잡으로 판단
   - ssthresh = cwnd / 2
   - cwnd = ssthresh + 3 MSS
   - Fast Recovery 진입

┌─────────────────────────────────────────────────────────────────┐
│                     혼잡 제어 상태 전이                          │
│                                                                  │
│  Slow Start ──(cwnd >= ssthresh)──► Congestion Avoidance        │
│      │                                        │                  │
│      │                                        │                  │
│   (timeout)                              (3 dup ACKs)            │
│      │                                        │                  │
│      ▼                                        ▼                  │
│  Slow Start ◄──────────────────────── Fast Recovery             │
│                    (recovery 완료)                               │
└─────────────────────────────────────────────────────────────────┘
```

### 7.5 Fast Retransmit과 Fast Recovery

```
Fast Retransmit 시나리오

송신자                               수신자
    │                                  │
    │── Seq=1000 ─────────────────────►│
    │── Seq=2000 ──────X              │ (손실)
    │── Seq=3000 ─────────────────────►│
    │                                  │
    │◄───────────────── ACK=2000 (dup1)│
    │                                  │
    │── Seq=4000 ─────────────────────►│
    │◄───────────────── ACK=2000 (dup2)│
    │                                  │
    │── Seq=5000 ─────────────────────►│
    │◄───────────────── ACK=2000 (dup3)│
    │                                  │
    │  3개의 중복 ACK 수신!            │
    │  → RTO 기다리지 않고 즉시 재전송 │
    │                                  │
    │── Seq=2000 (재전송) ────────────►│
    │                                  │
    │◄─────────────────────── ACK=6000 │

Fast Recovery:
- 3 dup ACKs 후 ssthresh = cwnd/2
- cwnd = ssthresh + 3 (이미 수신된 세그먼트 고려)
- 새 ACK 수신 시 cwnd = ssthresh
- Congestion Avoidance로 전환
```

### 7.6 현대 혼잡 제어 알고리즘

| 알고리즘 | 특징 | 사용 환경 |
|----------|------|----------|
| Reno | 기본 AIMD, Fast Recovery | 표준 |
| NewReno | 부분 ACK 개선 | Reno 개선 |
| CUBIC | BIC 개선, Linux 기본 | 고속 네트워크 |
| BBR | 대역폭/RTT 기반 | Google, 고지연 네트워크 |
| Vegas | RTT 변화 기반 | 저지연 환경 |

```
CUBIC cwnd 증가

cwnd
  │
  │                              *
  │                           *     *
  │                        *           *
  │                     *                 *
  │                  *                       *
  │               *                             *
  │            *          cubic 함수              *
  │         *                                        *
  │      *
  │   *
  │ *
  │*
  └──────────────────────────────────────────────────── time

특징:
- W_max (마지막 혼잡 시 윈도우) 기억
- W_max에 빠르게 접근 후 느리게 증가
- 공정성과 확장성 우수
```

---

## 8. 연습 문제

### 문제 1: 3-Way Handshake 분석

다음 패킷 캡처를 분석하세요.

```
Packet 1: 192.168.1.10:50000 → 10.0.0.5:443
          SYN, Seq=1000000000

Packet 2: 10.0.0.5:443 → 192.168.1.10:50000
          SYN, ACK, Seq=2000000000, Ack=?

Packet 3: 192.168.1.10:50000 → 10.0.0.5:443
          ACK, Seq=?, Ack=?
```

a) Packet 2의 Ack 값은?
b) Packet 3의 Seq 값은?
c) Packet 3의 Ack 값은?

### 문제 2: 시퀀스 번호 계산

클라이언트가 서버에 5000 bytes 데이터를 전송합니다. MSS=1000 bytes입니다.

초기 시퀀스 번호가 10000일 때, 각 세그먼트의 Seq 번호와 예상 ACK를 계산하세요.

| 세그먼트 | 데이터 크기 | Seq | 예상 ACK |
|----------|------------|-----|----------|
| 1        | 1000       |     |          |
| 2        | 1000       |     |          |
| 3        | 1000       |     |          |
| 4        | 1000       |     |          |
| 5        | 1000       |     |          |

### 문제 3: 흐름 제어

수신자의 receive buffer가 10000 bytes입니다. 현재 2000 bytes가 버퍼에 있습니다.

a) 광고 윈도우 크기는?
b) 송신자가 4000 bytes를 전송하면, 새로운 윈도우 크기는?
c) 애플리케이션이 3000 bytes를 읽으면, 새로운 윈도우 크기는?

### 문제 4: 혼잡 제어

ssthresh = 16 MSS, cwnd = 1 MSS로 시작합니다.

a) 4번의 RTT 후 cwnd 크기는? (손실 없음)
b) cwnd = 32 MSS일 때 타임아웃 발생. 새로운 ssthresh와 cwnd는?
c) cwnd = 24 MSS일 때 3개의 중복 ACK 발생. 새로운 ssthresh와 cwnd는?

---

## 정답

### 문제 1 정답

a) Packet 2의 Ack = **1000000001** (클라이언트 Seq + 1)
b) Packet 3의 Seq = **1000000001** (SYN은 1바이트로 간주)
c) Packet 3의 Ack = **2000000001** (서버 Seq + 1)

### 문제 2 정답

| 세그먼트 | 데이터 크기 | Seq | 예상 ACK |
|----------|------------|-----|----------|
| 1        | 1000       | 10000 | 11000 |
| 2        | 1000       | 11000 | 12000 |
| 3        | 1000       | 12000 | 13000 |
| 4        | 1000       | 13000 | 14000 |
| 5        | 1000       | 14000 | 15000 |

### 문제 3 정답

a) 광고 윈도우 = 10000 - 2000 = **8000 bytes**
b) 새 윈도우 = 10000 - 2000 - 4000 = **4000 bytes**
c) 새 윈도우 = 10000 - (2000 + 4000 - 3000) = **7000 bytes**

### 문제 4 정답

a) Slow Start 단계 (cwnd < ssthresh)
   - RTT 1: cwnd = 2 MSS
   - RTT 2: cwnd = 4 MSS
   - RTT 3: cwnd = 8 MSS
   - RTT 4: cwnd = **16 MSS**

b) 타임아웃 발생:
   - 새 ssthresh = 32 / 2 = **16 MSS**
   - 새 cwnd = **1 MSS**

c) 3 dup ACKs (Fast Retransmit):
   - 새 ssthresh = 24 / 2 = **12 MSS**
   - 새 cwnd = 12 + 3 = **15 MSS** (Fast Recovery)

---

## 9. 다음 단계

TCP의 핵심 개념을 이해했다면, UDP와 포트에 대해 학습하세요.

### 다음 레슨
- [11_UDP와_포트.md](./11_UDP와_포트.md) - UDP 특징, 포트 번호

### 관련 레슨
- [09_Routing_Protocols.md](./09_Routing_Protocols.md) - 네트워크 계층
- [12_DNS.md](./12_DNS.md) - DNS 동작 원리

### 추천 실습
1. Wireshark로 TCP 3-way handshake 캡처
2. `ss -i` 또는 `netstat -s`로 TCP 통계 확인
3. `tcpdump`로 TCP 플래그 분석

---

## 10. 참고 자료

### RFC 문서

- RFC 793 - TCP 기본 명세
- RFC 5681 - TCP Congestion Control
- RFC 7323 - TCP Extensions (Window Scaling, Timestamps)
- RFC 2018 - TCP Selective Acknowledgment Options

### 명령어 참고

```bash
# TCP 연결 상태 확인 (Linux)
ss -tan
netstat -an | grep tcp

# TCP 통계
netstat -s | grep -i tcp
cat /proc/net/snmp | grep Tcp

# TCP 튜닝 파라미터 확인
sysctl net.ipv4.tcp_congestion_control
sysctl net.core.rmem_max
sysctl net.ipv4.tcp_window_scaling

# Wireshark 필터
tcp.flags.syn == 1 && tcp.flags.ack == 0  # SYN 패킷
tcp.analysis.retransmission               # 재전송
tcp.analysis.duplicate_ack                # 중복 ACK
```

### 학습 자료

- [TCP/IP Illustrated, Vol. 1 - W. Richard Stevens](https://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469)
- [High Performance Browser Networking](https://hpbn.co/)
- [Cloudflare Blog - TCP](https://blog.cloudflare.com/tag/tcp/)

---

**문서 정보**
- 최종 수정: 2024년
- 난이도: ⭐⭐⭐
- 예상 학습 시간: 3-4시간
