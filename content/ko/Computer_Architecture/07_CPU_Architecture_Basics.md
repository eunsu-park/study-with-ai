# CPU 구조 기초

## 개요

CPU(Central Processing Unit)는 컴퓨터의 두뇌로서, 프로그램의 명령어를 해석하고 실행하는 핵심 장치입니다. 이 레슨에서는 CPU의 내부 구성요소, 레지스터의 종류, 데이터패스 구조, 그리고 명령어 실행 사이클에 대해 상세히 학습합니다.

**난이도**: ⭐⭐

**선수 지식**: 논리 게이트, 순차 논리 회로, 조합 논리 회로

---

## 목차

1. [CPU의 구성요소](#1-cpu의-구성요소)
2. [레지스터 종류](#2-레지스터-종류)
3. [데이터패스](#3-데이터패스)
4. [명령어 실행 사이클 상세](#4-명령어-실행-사이클-상세)
5. [단일 사이클 vs 다중 사이클](#5-단일-사이클-vs-다중-사이클)
6. [연습 문제](#6-연습-문제)

---

## 1. CPU의 구성요소

### 1.1 CPU 전체 구조

```
┌──────────────────────────────────────────────────────────────────┐
│                            CPU                                    │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                    제어 장치 (Control Unit)                 │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │  │
│  │  │ 명령어 해독  │  │  제어 신호  │  │  타이밍 & 시퀀싱    │ │  │
│  │  │   (Decoder) │  │   생성기    │  │    (Sequencer)      │ │  │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘ │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌─────────────────────┐    ┌─────────────────────────────────┐  │
│  │   레지스터 파일      │    │      ALU (산술논리장치)          │  │
│  │  ┌─────┐ ┌─────┐   │    │  ┌─────────────────────────┐    │  │
│  │  │ R0  │ │ R1  │   │    │  │   산술 연산 유닛         │    │  │
│  │  ├─────┤ ├─────┤   │    │  │   (+, -, *, /)          │    │  │
│  │  │ R2  │ │ R3  │   │    │  ├─────────────────────────┤    │  │
│  │  ├─────┤ ├─────┤   │    │  │   논리 연산 유닛         │    │  │
│  │  │ ... │ │ ... │   │    │  │   (AND, OR, XOR, NOT)   │    │  │
│  │  ├─────┤ ├─────┤   │    │  ├─────────────────────────┤    │  │
│  │  │ PC  │ │ IR  │   │    │  │   시프트 유닛            │    │  │
│  │  └─────┘ └─────┘   │    │  │   (<<, >>)              │    │  │
│  └─────────────────────┘    └─────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                   내부 버스 (Internal Bus)                  │  │
│  └────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │    시스템 버스     │
                    └───────────────────┘
```

### 1.2 ALU (Arithmetic Logic Unit)

ALU는 CPU에서 실제 연산을 수행하는 핵심 장치입니다.

```
                    ┌──────────────┐
        A ─────────►│              │
        (피연산자1)  │              │
                    │     ALU      │────────► 결과
        B ─────────►│              │
        (피연산자2)  │              │────────► 상태 플래그
                    │              │          (Zero, Carry,
        연산 코드 ──►│              │           Overflow, Sign)
        (Op Code)   └──────────────┘
```

#### ALU가 수행하는 연산

| 연산 종류 | 연산 | 설명 |
|-----------|------|------|
| 산술 연산 | ADD | 덧셈 |
| | SUB | 뺄셈 |
| | MUL | 곱셈 |
| | DIV | 나눗셈 |
| | INC | 1 증가 |
| | DEC | 1 감소 |
| 논리 연산 | AND | 논리곱 |
| | OR | 논리합 |
| | XOR | 배타적 논리합 |
| | NOT | 논리 부정 |
| 시프트 연산 | SHL | 왼쪽 시프트 |
| | SHR | 오른쪽 시프트 (논리) |
| | SAR | 오른쪽 시프트 (산술) |
| 비교 연산 | CMP | 비교 (뺄셈 후 플래그 설정) |

#### 상태 플래그 레지스터

```
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ S │ Z │ - │ A │ - │ P │ - │ C │
└───┴───┴───┴───┴───┴───┴───┴───┘
  │   │       │       │       │
  │   │       │       │       └─ Carry (자리올림/내림)
  │   │       │       └───────── Parity (패리티)
  │   │       └───────────────── Auxiliary Carry
  │   └───────────────────────── Zero (결과가 0)
  └───────────────────────────── Sign (부호, 음수면 1)

추가 플래그:
- Overflow (O): 오버플로우 발생
- Interrupt (I): 인터럽트 허용 여부
- Direction (D): 문자열 연산 방향
```

### 1.3 제어 장치 (Control Unit)

제어 장치는 명령어를 해독하고 각 구성요소에 적절한 제어 신호를 보내는 역할을 합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                      제어 장치 (CU)                          │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              명령어 레지스터 (IR)                     │   │
│  │    ┌────────────┬────────────┬────────────────┐     │   │
│  │    │  Opcode    │   Rs/Rd    │   Immediate    │     │   │
│  │    │  (연산코드) │  (레지스터) │   (즉시값)     │     │   │
│  │    └────────────┴────────────┴────────────────┘     │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              명령어 디코더 (Decoder)                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│           ┌───────────────┼───────────────┐                │
│           ▼               ▼               ▼                │
│     ┌──────────┐   ┌──────────┐   ┌──────────┐            │
│     │ ALU 제어 │   │ 레지스터 │   │ 메모리   │            │
│     │   신호   │   │   제어   │   │   제어   │            │
│     └──────────┘   └──────────┘   └──────────┘            │
└─────────────────────────────────────────────────────────────┘
```

#### 제어 신호 예시

| 제어 신호 | 기능 |
|-----------|------|
| RegWrite | 레지스터 쓰기 활성화 |
| ALUSrc | ALU 입력 소스 선택 |
| ALUOp | ALU 연산 종류 지정 |
| MemRead | 메모리 읽기 활성화 |
| MemWrite | 메모리 쓰기 활성화 |
| MemtoReg | 메모리→레지스터 경로 선택 |
| Branch | 분기 여부 |
| Jump | 점프 여부 |

---

## 2. 레지스터 종류

### 2.1 범용 레지스터 (General Purpose Registers)

프로그래머가 자유롭게 사용할 수 있는 레지스터입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                      범용 레지스터 (x86-64)                      │
├─────────────┬─────────┬─────────┬──────────────────────────────┤
│   64비트    │  32비트 │  16비트 │           용도               │
├─────────────┼─────────┼─────────┼──────────────────────────────┤
│    RAX      │   EAX   │   AX    │ 누산기 (산술 연산 결과)       │
│    RBX      │   EBX   │   BX    │ 베이스 (메모리 주소 기준)     │
│    RCX      │   ECX   │   CX    │ 카운터 (반복문 카운터)        │
│    RDX      │   EDX   │   DX    │ 데이터 (입출력 연산)          │
│    RSI      │   ESI   │   SI    │ 소스 인덱스                   │
│    RDI      │   EDI   │   DI    │ 목적지 인덱스                 │
│    RBP      │   EBP   │   BP    │ 베이스 포인터 (스택 프레임)   │
│    RSP      │   ESP   │   SP    │ 스택 포인터                   │
│   R8-R15    │ R8D-R15D│ R8W-R15W│ 추가 범용 레지스터 (x64)      │
└─────────────┴─────────┴─────────┴──────────────────────────────┘
```

#### 레지스터 크기 관계 (x86)

```
64비트: ├──────────────────────────────────────────────────────────┤ RAX
32비트:                                 ├──────────────────────────┤ EAX
16비트:                                                 ├──────────┤ AX
 8비트:                                                 ├────┬─────┤
                                                         AH    AL
```

### 2.2 특수 목적 레지스터

프로세서 동작에 필수적인 레지스터들입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                     특수 목적 레지스터                           │
├──────────────┬──────────────────────────────────────────────────┤
│   레지스터    │                    역할                          │
├──────────────┼──────────────────────────────────────────────────┤
│ PC (Program  │ 다음에 실행할 명령어의 주소를 저장                │
│  Counter)    │ 명령어 인출 후 자동 증가                          │
├──────────────┼──────────────────────────────────────────────────┤
│ IR (Instruc- │ 현재 실행 중인 명령어를 저장                      │
│ tion Reg.)   │ 제어 장치가 해독하는 대상                         │
├──────────────┼──────────────────────────────────────────────────┤
│ MAR (Memory  │ 접근할 메모리 주소를 저장                         │
│ Address Reg.)│ 주소 버스에 연결                                  │
├──────────────┼──────────────────────────────────────────────────┤
│ MBR/MDR      │ 메모리에서 읽거나 쓸 데이터를 저장                │
│ (Memory Data)│ 데이터 버스에 연결                                │
├──────────────┼──────────────────────────────────────────────────┤
│ SP (Stack    │ 스택의 최상단 주소를 저장                         │
│  Pointer)    │ PUSH/POP 연산 시 자동 조정                        │
├──────────────┼──────────────────────────────────────────────────┤
│ PSW/FLAGS    │ 프로세서 상태 정보 저장                           │
│ (Status Reg.)│ Zero, Carry, Overflow 등의 플래그                 │
└──────────────┴──────────────────────────────────────────────────┘
```

#### PC (프로그램 카운터) 동작

```
메모리:                              PC 동작:
┌─────────────┐
│ 0x1000: ADD │  ◄─── PC = 0x1000 (현재)
├─────────────┤
│ 0x1004: SUB │  ◄─── PC = 0x1004 (다음)
├─────────────┤
│ 0x1008: MUL │  ◄─── PC = 0x1008
├─────────────┤
│ 0x100C: JMP │  ◄─── 분기 시 PC 값 변경
├─────────────┤
│    ...      │
└─────────────┘

순차 실행: PC = PC + 명령어 크기
분기 실행: PC = 분기 대상 주소
```

### 2.3 ARM 레지스터 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                      ARM 레지스터 (AArch64)                      │
├──────────────┬──────────────────────────────────────────────────┤
│   레지스터    │                    역할                          │
├──────────────┼──────────────────────────────────────────────────┤
│   X0 - X7    │ 인자 전달 및 반환값 레지스터                      │
│   X8         │ 간접 결과 레지스터                                │
│   X9 - X15   │ 임시 레지스터 (caller-saved)                      │
│  X16 - X17   │ 인트라-프로시저 호출 레지스터                     │
│   X18        │ 플랫폼 레지스터                                   │
│  X19 - X28   │ Callee-saved 레지스터                             │
│   X29 (FP)   │ 프레임 포인터                                     │
│   X30 (LR)   │ 링크 레지스터 (반환 주소)                         │
│   SP         │ 스택 포인터                                       │
│   PC         │ 프로그램 카운터                                   │
└──────────────┴──────────────────────────────────────────────────┘
```

---

## 3. 데이터패스

### 3.1 데이터패스 개념

데이터패스는 CPU 내에서 데이터가 이동하는 경로와 이 경로에서 데이터를 처리하는 기능 유닛들의 집합입니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│                         기본 데이터패스                              │
│                                                                     │
│    ┌──────┐         ┌──────────────┐                               │
│    │  PC  │────────►│   명령어     │                               │
│    └──────┘         │   메모리     │                               │
│        │            └──────┬───────┘                               │
│        │                   │                                        │
│        ▼                   ▼                                        │
│    ┌──────┐         ┌──────────────┐         ┌──────────────┐      │
│    │ +4   │         │  명령어 IR   │────────►│  제어 장치   │      │
│    └──────┘         └──────┬───────┘         └──────┬───────┘      │
│                            │                        │               │
│                            ▼                        ▼               │
│                    ┌───────────────┐         제어 신호들            │
│         ┌─────────┤  레지스터     │                                │
│         │         │    파일       │                                │
│         │         └───┬───────┬───┘                                │
│         │             │       │                                     │
│         │             ▼       ▼                                     │
│         │         ┌───────────────┐                                │
│         │         │     ALU       │                                │
│         │         └───────┬───────┘                                │
│         │                 │                                         │
│         │                 ▼                                         │
│         │         ┌───────────────┐                                │
│         └────────►│  데이터       │                                │
│                   │  메모리       │                                │
│                   └───────────────┘                                │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 MIPS 데이터패스 (상세)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              MIPS 데이터패스                                 │
│                                                                             │
│                                                                             │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                         명령어 인출 (IF)                            │  │
│    │                                                                    │  │
│    │   ┌──────┐    ┌──────┐    ┌────────────────┐                       │  │
│    │   │  PC  │───►│ +4   │    │   명령어       │                       │  │
│    │   └──────┘    └───┬──┘    │   메모리       │                       │  │
│    │       │           │       └────────┬───────┘                       │  │
│    │       └───────────┴────────────────┘                               │  │
│    └────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼ [31:0] 명령어                          │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                      명령어 해독 (ID)                               │  │
│    │                                                                    │  │
│    │    [25:21]  ┌──────────────┐                                       │  │
│    │    ────────►│   Read       │───► Read Data 1                       │  │
│    │    [20:16]  │   Register   │                                       │  │
│    │    ────────►│   File       │───► Read Data 2                       │  │
│    │    [15:11]  │              │                                       │  │
│    │    ────────►│   Write Reg  │◄── Write Data                         │  │
│    │             └──────────────┘                                       │  │
│    │                                                                    │  │
│    │    [15:0]   ┌──────────────┐                                       │  │
│    │    ────────►│  Sign        │───► 32비트 즉시값                      │  │
│    │             │  Extend      │                                       │  │
│    │             └──────────────┘                                       │  │
│    └────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼                                        │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                         실행 (EX)                                   │  │
│    │                                                                    │  │
│    │    Read Data 1 ───►┌──────────────┐                                │  │
│    │                    │              │                                │  │
│    │    MUX 출력    ───►│     ALU      │───► ALU 결과                   │  │
│    │                    │              │───► Zero 플래그                │  │
│    │                    └──────────────┘                                │  │
│    │                                                                    │  │
│    │    Read Data 2 ───►┌──────┐                                        │  │
│    │    즉시값      ───►│ MUX  │───► ALU 입력 B                         │  │
│    │                    └──────┘                                        │  │
│    │                     ▲ ALUSrc                                       │  │
│    └────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼                                        │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                      메모리 접근 (MEM)                              │  │
│    │                                                                    │  │
│    │    ALU 결과 ─────►┌────────────────┐                               │  │
│    │    (주소)         │   데이터       │───► Read Data                 │  │
│    │                   │   메모리       │                               │  │
│    │    Write Data ───►│               │                               │  │
│    │                   └────────────────┘                               │  │
│    │                    ▲ MemRead/MemWrite                              │  │
│    └────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼                                        │
│    ┌────────────────────────────────────────────────────────────────────┐  │
│    │                       쓰기 (WB)                                     │  │
│    │                                                                    │  │
│    │    ALU 결과    ───►┌──────┐                                        │  │
│    │    Memory Data ───►│ MUX  │───► 레지스터 파일 Write Data           │  │
│    │                    └──────┘                                        │  │
│    │                     ▲ MemtoReg                                     │  │
│    └────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 데이터패스 구성 요소

| 구성 요소 | 기능 | 제어 신호 |
|-----------|------|-----------|
| PC | 다음 명령어 주소 저장 | - |
| 명령어 메모리 | 명령어 저장 및 제공 | - |
| 레지스터 파일 | 레지스터 읽기/쓰기 | RegWrite |
| ALU | 산술/논리 연산 | ALUOp |
| 데이터 메모리 | 데이터 저장/로드 | MemRead, MemWrite |
| MUX | 데이터 경로 선택 | ALUSrc, MemtoReg |
| Sign Extend | 16비트 → 32비트 확장 | - |

---

## 4. 명령어 실행 사이클 상세

### 4.1 기본 실행 사이클

```
┌─────────────────────────────────────────────────────────────────┐
│                    명령어 실행 사이클                            │
│                                                                 │
│   ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌──────┐ │
│   │ Fetch  │──►│ Decode │──►│Execute │──►│ Memory │──►│Write │ │
│   │ (인출) │   │ (해독) │   │ (실행) │   │ (접근) │   │Back  │ │
│   └────────┘   └────────┘   └────────┘   └────────┘   └──────┘ │
│       │                                                   │     │
│       └───────────────────────────────────────────────────┘     │
│                           반복                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 각 단계 상세

#### 1단계: 명령어 인출 (Instruction Fetch)

```
동작:
1. PC의 값을 MAR로 복사
2. 메모리[MAR]의 내용을 MBR로 읽음
3. MBR의 내용을 IR로 복사
4. PC = PC + 명령어 크기

마이크로 연산:
MAR ← PC
MBR ← Memory[MAR]
IR ← MBR
PC ← PC + 4

타이밍 다이어그램:
─────┬─────┬─────┬─────┬─────
 T0  │ T1  │ T2  │ T3  │
─────┴─────┴─────┴─────┴─────
MAR←PC    MBR←Mem  IR←MBR  PC←PC+4
```

#### 2단계: 명령어 해독 (Instruction Decode)

```
동작:
1. IR의 opcode 필드 분석
2. 피연산자 주소 계산
3. 필요한 레지스터 값 읽기

마이크로 연산:
A ← Regs[IR[25:21]]      // rs 레지스터 읽기
B ← Regs[IR[20:16]]      // rt 레지스터 읽기
ALUOut ← PC + (sign-extend(IR[15:0]) << 2)  // 분기 주소 계산

명령어 형식 분석 (MIPS):
┌────────┬───────┬───────┬───────┬───────┬────────┐
│ opcode │  rs   │  rt   │  rd   │ shamt │ funct  │  R-type
│  6비트 │ 5비트 │ 5비트 │ 5비트 │ 5비트 │ 6비트  │
└────────┴───────┴───────┴───────┴───────┴────────┘

┌────────┬───────┬───────┬─────────────────────────┐
│ opcode │  rs   │  rt   │       immediate         │  I-type
│  6비트 │ 5비트 │ 5비트 │        16비트           │
└────────┴───────┴───────┴─────────────────────────┘
```

#### 3단계: 명령어 실행 (Execute)

```
명령어 종류별 실행:

1. 산술/논리 연산 (R-type):
   ALUOut ← A op B

   예: ADD $t0, $t1, $t2
   ALUOut ← Regs[$t1] + Regs[$t2]

2. 메모리 참조:
   ALUOut ← A + sign-extend(IR[15:0])

   예: LW $t0, 100($t1)
   ALUOut ← Regs[$t1] + 100

3. 분기:
   if (A == B) PC ← ALUOut

   예: BEQ $t0, $t1, label
   if (Regs[$t0] == Regs[$t1])
       PC ← PC + offset × 4
```

#### 4단계: 메모리 접근 (Memory Access)

```
Load 명령어:
MDR ← Memory[ALUOut]

예: LW $t0, 100($t1)
MDR ← Memory[Regs[$t1] + 100]

Store 명령어:
Memory[ALUOut] ← B

예: SW $t0, 100($t1)
Memory[Regs[$t1] + 100] ← Regs[$t0]
```

#### 5단계: 쓰기 (Write Back)

```
R-type 명령어:
Regs[IR[15:11]] ← ALUOut

예: ADD $t0, $t1, $t2
Regs[$t0] ← ALUOut

Load 명령어:
Regs[IR[20:16]] ← MDR

예: LW $t0, 100($t1)
Regs[$t0] ← MDR
```

### 4.3 명령어별 실행 예시

```
예시: ADD $t0, $t1, $t2 (R-type)

단계 1 (IF):
  MAR ← PC
  IR ← Memory[MAR]
  PC ← PC + 4

단계 2 (ID):
  A ← Regs[$t1]
  B ← Regs[$t2]

단계 3 (EX):
  ALUOut ← A + B

단계 4 (MEM):
  (없음 - 메모리 접근 필요 없음)

단계 5 (WB):
  Regs[$t0] ← ALUOut


예시: LW $t0, 100($t1) (I-type, Load)

단계 1 (IF):
  MAR ← PC
  IR ← Memory[MAR]
  PC ← PC + 4

단계 2 (ID):
  A ← Regs[$t1]

단계 3 (EX):
  ALUOut ← A + 100

단계 4 (MEM):
  MDR ← Memory[ALUOut]

단계 5 (WB):
  Regs[$t0] ← MDR
```

---

## 5. 단일 사이클 vs 다중 사이클

### 5.1 단일 사이클 구현

```
┌─────────────────────────────────────────────────────────────────┐
│                    단일 사이클 (Single-Cycle)                    │
│                                                                 │
│  특징: 모든 명령어가 한 클럭 사이클에 완료                       │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    1 클럭 사이클                          │  │
│  │  ┌─────┬─────┬─────┬─────┬─────┐                         │  │
│  │  │ IF  │ ID  │ EX  │ MEM │ WB  │                         │  │
│  │  └─────┴─────┴─────┴─────┴─────┘                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  클럭 주기 = 가장 긴 명령어(Load)의 실행 시간                   │
│                                                                 │
│  예시 (각 단계 소요 시간):                                      │
│  - IF: 200ps                                                   │
│  - ID: 100ps                                                   │
│  - EX: 200ps                                                   │
│  - MEM: 200ps                                                  │
│  - WB: 100ps                                                   │
│                                                                 │
│  클럭 주기 = 200 + 100 + 200 + 200 + 100 = 800ps               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 단일 사이클 장단점

| 장점 | 단점 |
|------|------|
| 구현이 간단 | 클럭 주기가 김 (가장 느린 명령어 기준) |
| 제어 논리가 단순 | 모든 명령어가 동일한 시간 소요 |
| CPI = 1 (명령어당 1사이클) | 하드웨어 자원 활용도 낮음 |

### 5.2 다중 사이클 구현

```
┌─────────────────────────────────────────────────────────────────┐
│                    다중 사이클 (Multi-Cycle)                     │
│                                                                 │
│  특징: 명령어를 여러 클럭 사이클에 걸쳐 실행                     │
│                                                                 │
│  각 단계가 별도의 사이클:                                        │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐                       │
│  │ IF  │ │ ID  │ │ EX  │ │ MEM │ │ WB  │                       │
│  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘                       │
│  사이클1 사이클2 사이클3 사이클4 사이클5                         │
│                                                                 │
│  클럭 주기 = 가장 긴 단계의 시간                                │
│  = max(200, 100, 200, 200, 100) = 200ps                        │
│                                                                 │
│  명령어별 사이클 수:                                            │
│  - Load:  5사이클 (IF, ID, EX, MEM, WB)                        │
│  - Store: 4사이클 (IF, ID, EX, MEM)                            │
│  - R-type: 4사이클 (IF, ID, EX, WB)                            │
│  - Branch: 3사이클 (IF, ID, EX)                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 다중 사이클 상태 다이어그램

```
                    ┌─────────────────────────────────┐
                    │                                 │
                    ▼                                 │
              ┌──────────┐                           │
              │  IF      │                           │
              │ (인출)   │                           │
              └────┬─────┘                           │
                   │                                 │
                   ▼                                 │
              ┌──────────┐                           │
              │  ID      │                           │
              │ (해독)   │                           │
              └────┬─────┘                           │
                   │                                 │
         ┌─────────┼─────────┐                       │
         │         │         │                       │
         ▼         ▼         ▼                       │
    ┌────────┐ ┌────────┐ ┌────────┐                │
    │ MEM주소│ │ R-type │ │ Branch │───────────────┘
    │  계산  │ │  실행  │ │  완료  │
    └────┬───┘ └────┬───┘ └────────┘
         │         │
    ┌────┴────┐    │
    │         │    │
    ▼         ▼    │
┌───────┐ ┌───────┐│
│  Load │ │ Store ││
│  MEM  │ │  MEM  ││
└───┬───┘ └───────┘│
    │              │
    ▼              │
┌───────┐    ┌─────┴─────┐
│ Load  │    │  R-type   │
│  WB   │    │    WB     │
└───────┘    └───────────┘
```

### 5.3 성능 비교

```
┌─────────────────────────────────────────────────────────────────┐
│                        성능 비교 예시                            │
│                                                                 │
│  가정:                                                          │
│  - 명령어 분포: Load 25%, Store 10%, R-type 45%, Branch 20%    │
│  - 단일 사이클 클럭: 800ps                                      │
│  - 다중 사이클 클럭: 200ps                                      │
│                                                                 │
│  단일 사이클:                                                   │
│  평균 시간 = 800ps × 1 = 800ps/명령어                          │
│                                                                 │
│  다중 사이클:                                                   │
│  평균 CPI = 0.25×5 + 0.10×4 + 0.45×4 + 0.20×3                  │
│           = 1.25 + 0.40 + 1.80 + 0.60 = 4.05                   │
│  평균 시간 = 200ps × 4.05 = 810ps/명령어                       │
│                                                                 │
│  결론: 이 예시에서는 거의 비슷한 성능                           │
│  (하지만 다중 사이클은 하드웨어 자원을 더 효율적으로 사용)       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 두 방식의 비교 정리

| 특성 | 단일 사이클 | 다중 사이클 |
|------|-------------|-------------|
| CPI | 1 | 가변 (3~5) |
| 클럭 주기 | 길다 (가장 긴 명령어) | 짧다 (가장 긴 단계) |
| 제어 논리 | 단순 | 복잡 (FSM 필요) |
| 하드웨어 사용 | 비효율적 | 효율적 (공유) |
| 메모리 | 명령어/데이터 분리 | 통합 가능 |
| 구현 복잡도 | 낮음 | 중간 |

---

## 6. 연습 문제

### 기초 문제

1. CPU의 3대 구성요소는 무엇인가?

2. 다음 레지스터의 역할을 설명하시오:
   - (a) PC (Program Counter)
   - (b) IR (Instruction Register)
   - (c) MAR (Memory Address Register)

3. ALU에서 수행하는 연산의 종류 3가지를 쓰시오.

### 데이터패스 문제

4. 다음 MIPS 명령어 실행 시 활성화되는 제어 신호를 모두 고르시오:

   `ADD $t0, $t1, $t2`

   - (a) RegWrite
   - (b) ALUSrc
   - (c) MemRead
   - (d) MemWrite
   - (e) MemtoReg

5. `LW $t0, 100($t1)` 명령어의 5단계 실행 과정을 순서대로 설명하시오.

### 성능 분석 문제

6. 단일 사이클 CPU에서 각 단계의 소요 시간이 다음과 같을 때:
   - IF: 250ps
   - ID: 150ps
   - EX: 200ps
   - MEM: 300ps
   - WB: 100ps

   (a) 클럭 주기는 얼마인가?
   (b) 1초에 몇 개의 명령어를 실행할 수 있는가?

7. 다중 사이클 CPU에서 명령어 분포가 다음과 같을 때 평균 CPI를 구하시오:
   - Load: 30% (5 사이클)
   - Store: 15% (4 사이클)
   - R-type: 40% (4 사이클)
   - Branch: 15% (3 사이클)

### 심화 문제

8. 폰 노이만 병목을 해결하기 위한 CPU 설계 기법 3가지를 설명하시오.

9. 다음 코드 시퀀스가 단일 사이클 CPU와 다중 사이클 CPU에서 실행될 때 각각의 총 실행 시간을 계산하시오 (위 6번 문제의 시간 가정 사용):

```assembly
LW   $t0, 0($s0)
ADD  $t1, $t0, $t2
SW   $t1, 4($s0)
```

<details>
<summary>정답</summary>

1. ALU (산술논리장치), Control Unit (제어장치), Register (레지스터)

2.
   - (a) PC: 다음에 실행할 명령어의 주소를 저장
   - (b) IR: 현재 실행 중인 명령어를 저장
   - (c) MAR: 접근할 메모리 주소를 저장

3. 산술 연산 (덧셈, 뺄셈 등), 논리 연산 (AND, OR 등), 시프트 연산 (또는 비교 연산)

4. (a) RegWrite - 레지스터에 결과를 쓰므로 활성화
   - ALUSrc = 0 (레지스터 값 사용)
   - MemtoReg = 0 (ALU 결과 선택)

5.
   - IF: PC에서 명령어 인출, PC+4
   - ID: $t1 레지스터 값 읽기, 오프셋(100) 부호 확장
   - EX: $t1 + 100 주소 계산
   - MEM: 계산된 주소에서 데이터 읽기
   - WB: 읽은 데이터를 $t0에 저장

6.
   - (a) 클럭 주기 = 250 + 150 + 200 + 300 + 100 = 1000ps = 1ns
   - (b) 1초 / 1ns = 10^9 = 1 GIPS (Giga Instructions Per Second)

7. 평균 CPI = 0.30×5 + 0.15×4 + 0.40×4 + 0.15×3
           = 1.50 + 0.60 + 1.60 + 0.45 = 4.15

8.
   - 캐시 메모리: CPU와 메모리 사이에 고속 메모리 배치
   - 파이프라이닝: 여러 명령어를 동시에 처리
   - 프리페치: 필요한 데이터를 미리 가져옴

9.
   - 단일 사이클: 3 × 1000ps = 3000ps = 3ns
   - 다중 사이클: (5 + 4 + 4) × 300ps = 13 × 300ps = 3900ps = 3.9ns
     (클럭 주기 = max(250, 150, 200, 300, 100) = 300ps)

</details>

---

## 다음 단계

- [08_Control_Unit.md](./08_Control_Unit.md) - 하드와이어드/마이크로프로그램 제어

---

## 참고 자료

- Computer Organization and Design (Patterson & Hennessy)
- Computer Architecture: A Quantitative Approach (Hennessy & Patterson)
- [CPU 시뮬레이터](https://cpuvisualsimulator.github.io/)
- [MIPS 데이터패스 시뮬레이터](https://courses.cs.washington.edu/courses/cse378/09au/lectures/datapath.html)
