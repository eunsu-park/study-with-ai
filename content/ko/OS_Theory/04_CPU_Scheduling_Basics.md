# CPU 스케줄링 기초

## 개요

CPU 스케줄링은 준비 상태의 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 과정입니다. 이 레슨에서는 CPU burst와 I/O burst, 스케줄링 목표, 선점/비선점 스케줄링, 그리고 다양한 스케줄러의 역할을 학습합니다.

---

## 목차

1. [CPU 스케줄링이란?](#1-cpu-스케줄링이란)
2. [CPU Burst와 I/O Burst](#2-cpu-burst와-io-burst)
3. [스케줄링 목표](#3-스케줄링-목표)
4. [선점 vs 비선점 스케줄링](#4-선점-vs-비선점-스케줄링)
5. [스케줄러 종류](#5-스케줄러-종류)
6. [디스패처](#6-디스패처)
7. [연습 문제](#7-연습-문제)

---

## 1. CPU 스케줄링이란?

### 정의

```
CPU 스케줄링 = Ready 큐에 있는 프로세스 중
              CPU를 할당할 프로세스를 선택하는 것

┌─────────────────────────────────────────────────────────┐
│                   CPU 스케줄링의 위치                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌────────┐    ┌─────────────────────────────────────┐  │
│  │ New    │───▶│          Ready Queue               │  │
│  │프로세스 │    │  P1 → P2 → P3 → P4 → ...          │  │
│  └────────┘    └─────────────┬───────────────────────┘  │
│                              │                          │
│                              │ CPU 스케줄러가 선택       │
│                              ▼                          │
│                       ┌───────────┐                     │
│                       │    CPU    │                     │
│                       │  (실행)    │                     │
│                       └─────┬─────┘                     │
│                             │                           │
│            ┌────────────────┼────────────────┐          │
│            ▼                ▼                ▼          │
│       ┌─────────┐    ┌───────────┐    ┌─────────┐      │
│       │ 종료    │    │ I/O 대기  │    │Ready로  │      │
│       │(Terminate)│   │ (Wait)   │    │복귀     │      │
│       └─────────┘    └───────────┘    └─────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 스케줄링이 필요한 이유

```
1. CPU 이용률 최대화
   - CPU가 놀지 않도록 항상 실행할 프로세스 준비

2. 공정한 자원 분배
   - 모든 프로세스에게 적절한 CPU 시간 제공

3. 시스템 성능 최적화
   - 처리량 증가, 응답 시간 감소

4. 멀티태스킹 지원
   - 여러 프로세스가 동시에 실행되는 것처럼 보이게 함

┌──────────────────────────────────────────────────────────┐
│             스케줄링 없이 vs 스케줄링 사용                 │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  스케줄링 없이 (순차 실행):                               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ P1 (I/O대기)    │ P2 (I/O대기)    │ P3 (I/O대기)   │ │
│  └─────────────────────────────────────────────────────┘ │
│  시간: ████░░░░░░░████░░░░░░░████░░░░                    │
│               CPU 유휴 시간 많음                          │
│                                                          │
│  스케줄링 사용:                                          │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ P1 │ P2 │ P3 │ P1 │ P2 │ P3 │ ...                  │ │
│  └─────────────────────────────────────────────────────┘ │
│  시간: ██████████████████████████                        │
│               CPU 유휴 시간 최소화                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 2. CPU Burst와 I/O Burst

### Burst란?

```
프로세스 실행 = CPU Burst와 I/O Burst의 반복

┌─────────────────────────────────────────────────────────┐
│                    프로세스 실행 사이클                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  시작 ──▶ CPU Burst ──▶ I/O Burst ──▶ CPU Burst ──▶ ... │
│             │            │            │                 │
│             ▼            ▼            ▼                 │
│          연산 수행      I/O 대기     연산 수행           │
│          (Running)     (Waiting)   (Running)           │
│                                                         │
└─────────────────────────────────────────────────────────┘

시간축 예시:

프로세스 P1:
┌──────┬──────────┬───────┬──────────┬──────┬──────┐
│ CPU  │  I/O     │  CPU  │   I/O    │ CPU  │ 종료  │
│ 10ms │  50ms    │  5ms  │  30ms    │ 8ms  │      │
└──────┴──────────┴───────┴──────────┴──────┴──────┘
```

### CPU-bound vs I/O-bound 프로세스

```
┌──────────────────────────────────────────────────────────┐
│              프로세스 유형에 따른 Burst 패턴              │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  CPU-bound 프로세스 (계산 집약적):                        │
│  ┌────────────────────┬──┬────────────────────┬──┐       │
│  │     긴 CPU burst    │IO│     긴 CPU burst    │IO│       │
│  └────────────────────┴──┴────────────────────┴──┘       │
│  예: 과학 계산, 비디오 인코딩, 컴파일러                    │
│                                                          │
│  I/O-bound 프로세스 (입출력 집약적):                      │
│  ┌──┬─────┬──┬─────┬──┬─────┬──┬─────┐                   │
│  │CP│ I/O │CP│ I/O │CP│ I/O │CP│ I/O │                   │
│  └──┴─────┴──┴─────┴──┴─────┴──┴─────┘                   │
│  예: 텍스트 에디터, 웹 브라우저, 대화형 프로그램           │
│                                                          │
└──────────────────────────────────────────────────────────┘

┌─────────────────┬────────────────┬────────────────────────┐
│      특성        │  CPU-bound    │      I/O-bound        │
├─────────────────┼────────────────┼────────────────────────┤
│ CPU burst 길이  │ 김              │ 짧음                  │
│ I/O burst 빈도  │ 낮음           │ 높음                   │
│ 스케줄링 요구   │ 긴 시간 슬라이스 │ 빠른 응답 시간         │
│ 예시            │ 수치 연산       │ 웹 서버, 데이터베이스   │
└─────────────────┴────────────────┴────────────────────────┘
```

### CPU Burst 분포

```
빈도
 ↑
 │  ██
 │  ██
 │  ████
 │  ██████
 │  ████████
 │  ██████████
 │  ████████████
 │  ██████████████
 │  ████████████████
 │  ██████████████████
 └────────────────────────────────▶ CPU Burst 길이

대부분의 프로세스는 짧은 CPU burst를 가짐
→ I/O-bound 프로세스가 많음
→ 짧은 프로세스를 먼저 처리하면 평균 대기 시간 감소
```

---

## 3. 스케줄링 목표

### 주요 성능 지표

```
┌─────────────────────────────────────────────────────────┐
│                    스케줄링 성능 지표                    │
├───────────────────┬─────────────────────────────────────┤
│ CPU 이용률        │ CPU가 작업을 수행하는 시간의 비율    │
│ (CPU Utilization) │ 목표: 최대화 (40%~90%)              │
├───────────────────┼─────────────────────────────────────┤
│ 처리량            │ 단위 시간당 완료되는 프로세스 수      │
│ (Throughput)      │ 목표: 최대화                        │
├───────────────────┼─────────────────────────────────────┤
│ 총 처리 시간      │ 프로세스 제출 ~ 완료까지 걸린 시간   │
│ (Turnaround Time) │ = 대기 시간 + 실행 시간 + I/O 시간   │
│                   │ 목표: 최소화                        │
├───────────────────┼─────────────────────────────────────┤
│ 대기 시간         │ Ready 큐에서 대기한 총 시간          │
│ (Waiting Time)    │ 목표: 최소화                        │
├───────────────────┼─────────────────────────────────────┤
│ 응답 시간         │ 요청 제출 ~ 첫 응답까지 시간         │
│ (Response Time)   │ 대화형 시스템에서 중요               │
│                   │ 목표: 최소화                        │
└───────────────────┴─────────────────────────────────────┘
```

### 시간 개념 시각화

```
프로세스 P 타임라인:

도착                 완료
  │                   │
  ▼                   ▼
──┬─────────────────────┬─────────────────────┬──▶ 시간
  │                     │                     │
  │◀── 총 처리 시간 (Turnaround Time) ───────▶│
  │                                           │
  │    대기    │  실행  │  대기  │  실행     │
  │◀─ Wait ─▶│       │◀ Wait ▶│           │
  │                                           │
  │◀─▶첫응답                                  │
  │Response                                   │
  │Time                                       │


계산 예시:
┌─────────────────────────────────────────────────────────┐
│ 프로세스 P:                                             │
│   도착 시간 = 0                                         │
│   실행 시간 = 10ms (총 CPU 사용 시간)                    │
│   완료 시간 = 25ms                                      │
│                                                         │
│ 총 처리 시간 (Turnaround) = 완료 - 도착 = 25 - 0 = 25ms  │
│ 대기 시간 (Waiting) = 총처리시간 - 실행시간 = 25 - 10 = 15ms │
└─────────────────────────────────────────────────────────┘
```

### 목표 간 트레이드오프

```
┌─────────────────────────────────────────────────────────┐
│                   스케줄링 목표 트레이드오프              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  CPU 이용률 ←─────────────────────▶ 응답 시간           │
│  (최대화)           상충 관계          (최소화)          │
│                                                         │
│  처리량 ←───────────────────────▶ 공정성               │
│  (최대화)        상충 관계        (균등 분배)           │
│                                                         │
│  시스템 유형에 따라 우선순위가 다름:                     │
│                                                         │
│  ┌────────────────┬───────────────────────────────────┐ │
│  │ 배치 시스템     │ 처리량, CPU 이용률 우선            │ │
│  ├────────────────┼───────────────────────────────────┤ │
│  │ 대화형 시스템   │ 응답 시간 우선                    │ │
│  ├────────────────┼───────────────────────────────────┤ │
│  │ 실시간 시스템   │ 마감시간 준수 우선                │ │
│  └────────────────┴───────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 선점 vs 비선점 스케줄링

### 비선점 스케줄링 (Non-preemptive)

```
┌─────────────────────────────────────────────────────────┐
│              비선점 스케줄링 (Non-preemptive)            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  • 프로세스가 CPU를 자발적으로 반환할 때까지 실행         │
│  • CPU를 강제로 빼앗지 않음                             │
│                                                         │
│  CPU 반환 시점:                                         │
│  1. 프로세스 종료                                       │
│  2. I/O 요청으로 대기 상태 전환                         │
│  3. yield() 등으로 자발적 양보                          │
│                                                         │
│  시간축:                                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │ P1 (10ms)              │ P2 (5ms)    │ P3 (3ms) │   │
│  └──────────────────────────────────────────────────┘   │
│  P2, P3가 도착해도 P1이 끝날 때까지 대기                  │
│                                                         │
│  장점: 구현 단순, 컨텍스트 스위치 오버헤드 적음           │
│  단점: 응답 시간 길어질 수 있음, 긴 프로세스가 독점 가능  │
│                                                         │
│  예시 알고리즘: FCFS, SJF (비선점)                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 선점 스케줄링 (Preemptive)

```
┌─────────────────────────────────────────────────────────┐
│                선점 스케줄링 (Preemptive)                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  • 스케줄러가 프로세스의 CPU를 강제로 빼앗을 수 있음      │
│  • 더 중요한 프로세스가 도착하면 즉시 CPU 할당 가능       │
│                                                         │
│  CPU 빼앗는 시점:                                       │
│  1. 타임 슬라이스(Time Quantum) 만료                    │
│  2. 높은 우선순위 프로세스 도착                          │
│  3. I/O 완료로 프로세스가 Ready로 전환                   │
│                                                         │
│  시간축 (Round Robin 예시):                             │
│  ┌──────┬──────┬──────┬──────┬──────┬──────┐           │
│  │  P1  │  P2  │  P3  │  P1  │  P2  │  P1  │           │
│  └──────┴──────┴──────┴──────┴──────┴──────┘           │
│  타임 슬라이스마다 프로세스 교체                         │
│                                                         │
│  장점: 응답 시간 개선, CPU 독점 방지                     │
│  단점: 컨텍스트 스위치 오버헤드, 동기화 이슈 복잡         │
│                                                         │
│  예시 알고리즘: RR, SRTF, Priority (선점)               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 비교

```
┌─────────────────┬─────────────────┬─────────────────────┐
│      특성        │    비선점       │       선점           │
├─────────────────┼─────────────────┼─────────────────────┤
│ CPU 빼앗김      │ 불가능          │ 가능                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 응답 시간       │ 길어질 수 있음   │ 짧음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 컨텍스트 스위치  │ 적음            │ 많음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 구현 복잡도     │ 낮음            │ 높음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 동기화 이슈     │ 적음            │ 경쟁 상태 주의 필요  │
├─────────────────┼─────────────────┼─────────────────────┤
│ 적합한 시스템   │ 배치 시스템      │ 대화형/실시간 시스템 │
└─────────────────┴─────────────────┴─────────────────────┘
```

### 스케줄링 결정 시점

```
┌─────────────────────────────────────────────────────────┐
│                CPU 스케줄링 결정 시점                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. Running → Waiting (I/O 요청)         [비선점]        │
│     • 프로세스가 자발적으로 CPU 반환                     │
│                                                         │
│  2. Running → Ready (인터럽트, 타임아웃)  [선점]          │
│     • 타임 슬라이스 만료                                │
│     • 높은 우선순위 프로세스 도착                        │
│                                                         │
│  3. Waiting → Ready (I/O 완료)           [선점 가능]     │
│     • I/O 완료된 프로세스가 현재 프로세스보다             │
│       우선순위가 높으면 선점 가능                        │
│                                                         │
│  4. Running → Terminated (종료)           [비선점]        │
│     • 프로세스 종료, 다음 프로세스 선택 필요             │
│                                                         │
│                                                         │
│  1번, 4번만 있으면: 비선점 스케줄링                      │
│  1~4번 모두 있으면: 선점 스케줄링                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 스케줄러 종류

### 3단계 스케줄러

```
┌─────────────────────────────────────────────────────────────┐
│                     3단계 스케줄러 구조                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                   작업 큐 (Job Queue)               │    │
│  │     디스크에 있는 모든 프로세스                      │    │
│  │     ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐                  │    │
│  │     │P1 │ │P2 │ │P3 │ │P4 │ │...│                  │    │
│  │     └───┘ └───┘ └───┘ └───┘ └───┘                  │    │
│  └───────────────────────┬─────────────────────────────┘    │
│                          │                                  │
│                    장기 스케줄러                             │
│                   (Long-term Scheduler)                    │
│                    • 작업 승인                              │
│                    • 멀티프로그래밍 정도 제어               │
│                    • 실행 빈도: 초~분 단위                  │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                   준비 큐 (Ready Queue)             │    │
│  │     메모리에 있는 실행 대기 프로세스                 │    │
│  │     ┌───┐ ┌───┐ ┌───┐                              │    │
│  │     │P1 │→│P2 │→│P3 │                              │    │
│  │     └───┘ └───┘ └───┘                              │    │
│  └──────────────┬────────────────────────┬─────────────┘    │
│                 │                        │                  │
│           단기 스케줄러           중기 스케줄러              │
│         (Short-term Scheduler) (Medium-term Scheduler)     │
│          • CPU 할당                • 스와핑                 │
│          • 실행 빈도: ms 단위       • 메모리 관리            │
│          • 가장 빈번                • 멀티프로그래밍 조절    │
│                 │                        │                  │
│                 ▼                        ▼                  │
│            ┌─────────┐           ┌───────────────┐          │
│            │   CPU   │           │   Suspended   │          │
│            │(Running)│           │    Queue      │          │
│            └─────────┘           └───────────────┘          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 장기 스케줄러 (Long-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│               장기 스케줄러 (Job Scheduler)              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • 디스크의 작업 → 메모리 (Ready Queue)                 │
│  • 어떤 프로세스를 시스템에 들일지 결정                  │
│  • 멀티프로그래밍 정도 (Degree) 제어                    │
│                                                         │
│  결정 기준:                                             │
│  • 시스템 자원 (메모리, CPU) 상태                       │
│  • CPU-bound와 I/O-bound 프로세스의 적절한 혼합          │
│                                                         │
│  실행 빈도: 드물게 (초~분 단위)                         │
│                                                         │
│  현대 시스템:                                           │
│  • 시분할 시스템에서는 거의 사용 안 함                   │
│  • 모든 프로세스를 바로 Ready Queue로                    │
│  • 가상 메모리가 메모리 관리를 담당                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 단기 스케줄러 (Short-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│               단기 스케줄러 (CPU Scheduler)              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • Ready Queue → CPU (Running)                         │
│  • 어떤 프로세스에게 CPU를 할당할지 결정                 │
│                                                         │
│  실행 빈도: 매우 자주 (밀리초 단위)                      │
│  → 빠른 알고리즘이 필수                                 │
│                                                         │
│  호출 시점:                                             │
│  • 타임 슬라이스 만료                                   │
│  • 프로세스 블로킹 (I/O 요청)                           │
│  • 프로세스 종료                                        │
│  • 인터럽트 발생                                        │
│                                                         │
│  사용 알고리즘:                                         │
│  • FCFS, SJF, Priority, Round Robin, MLFQ 등           │
│                                                         │
│  주의: 스케줄러 자체도 CPU 시간을 사용                   │
│       → 스케줄러 오버헤드 최소화 필요                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 중기 스케줄러 (Medium-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│              중기 스케줄러 (Swapper)                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • 스와핑 (Swapping) 관리                               │
│  • 메모리 ↔ 디스크 간 프로세스 이동                      │
│  • 멀티프로그래밍 정도 동적 조절                         │
│                                                         │
│  동작:                                                  │
│  ┌─────────────────────────────────────────────────┐    │
│  │    메모리 (Ready/Blocked)                       │    │
│  │    ┌───┐ ┌───┐ ┌───┐                           │    │
│  │    │P1 │ │P2 │ │P3 │  ← 메모리 부족 시         │    │
│  │    └───┘ └───┘ └───┘       P3를 swap out       │    │
│  └─────────────────────────────────────────────────┘    │
│              │ swap out          ▲ swap in             │
│              ▼                   │                     │
│  ┌─────────────────────────────────────────────────┐    │
│  │    디스크 (Suspended)                           │    │
│  │    ┌───┐ ┌───┐                                 │    │
│  │    │P4 │ │P5 │  → 메모리 여유 시 swap in       │    │
│  │    └───┘ └───┘                                 │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  Swap out 기준:                                         │
│  • 오래 대기 중인 프로세스                              │
│  • 낮은 우선순위 프로세스                               │
│  • 메모리를 많이 사용하는 프로세스                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 스케줄러 비교

```
┌────────────────────┬────────────────┬────────────────┬────────────────┐
│       특성          │   장기 스케줄러 │  단기 스케줄러  │  중기 스케줄러  │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 다른 이름          │ Job Scheduler  │ CPU Scheduler  │ Swapper       │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 전환               │ 디스크→메모리   │ Ready→Running  │ 메모리↔디스크  │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 실행 빈도          │ 드물게         │ 매우 자주      │ 가끔           │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 속도 요구          │ 느려도 됨      │ 매우 빨라야 함 │ 중간           │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 멀티프로그래밍     │ 전체 수 제어    │ 영향 없음      │ 동적 조절      │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 현대 시스템        │ 거의 사용 X    │ 핵심 사용      │ 가상메모리 대체 │
└────────────────────┴────────────────┴────────────────┴────────────────┘
```

---

## 6. 디스패처

### 디스패처란?

```
┌─────────────────────────────────────────────────────────┐
│                    디스패처 (Dispatcher)                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  디스패처 = CPU 스케줄러가 선택한 프로세스에게            │
│            실제로 CPU 제어권을 넘겨주는 모듈             │
│                                                         │
│  스케줄러와 디스패처 관계:                               │
│  ┌───────────────┐          ┌───────────────┐           │
│  │   스케줄러     │ ─결정──▶ │   디스패처    │ ─실행──▶   │
│  │ "P3를 실행"   │          │ CPU 할당 수행 │           │
│  └───────────────┘          └───────────────┘           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 디스패처 수행 작업

```
┌─────────────────────────────────────────────────────────┐
│                  디스패처 수행 작업                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 컨텍스트 스위치                                     │
│     • 현재 프로세스 상태를 PCB에 저장                   │
│     • 새 프로세스 상태를 PCB에서 복원                   │
│                                                         │
│  2. 사용자 모드로 전환                                  │
│     • 커널 모드 → 사용자 모드                           │
│                                                         │
│  3. 프로그램 재시작                                     │
│     • 새 프로세스의 적절한 위치로 점프                   │
│     • PC (프로그램 카운터) 설정                         │
│                                                         │
│  시간축:                                                │
│  ┌────────┬──────────────────┬────────────────────┐     │
│  │ P1 실행 │  디스패처 실행    │      P2 실행       │     │
│  │        │(디스패치 지연시간) │                   │     │
│  └────────┴──────────────────┴────────────────────┘     │
│           ↑                                             │
│      Dispatch Latency (가능한 짧아야 함)                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 디스패치 지연 시간 (Dispatch Latency)

```
디스패치 지연 시간 = 현재 프로세스 중단 ~ 새 프로세스 실행 시작

구성 요소:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. 인터럽트 처리 시간                                  │
│  2. 현재 프로세스 상태 저장                             │
│  3. 스케줄링 알고리즘 실행                              │
│  4. 새 프로세스 상태 복원                               │
│  5. 캐시/TLB 관련 비용                                  │
│                                                         │
│  일반적으로: 1~10 마이크로초                            │
│                                                         │
│  최소화 방법:                                           │
│  • 효율적인 스케줄링 알고리즘                           │
│  • 최적화된 컨텍스트 스위치 코드                        │
│  • 하드웨어 지원 활용                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 7. 연습 문제

### 문제 1: 기본 개념

다음 용어를 정의하세요.

1. CPU Burst
2. 처리량 (Throughput)
3. 총 처리 시간 (Turnaround Time)
4. 선점 스케줄링

<details>
<summary>정답 보기</summary>

1. **CPU Burst**: 프로세스가 CPU를 연속적으로 사용하는 시간. I/O 요청 없이 계산만 수행하는 구간.

2. **처리량 (Throughput)**: 단위 시간당 완료되는 프로세스의 수. 시스템 효율성의 지표.

3. **총 처리 시간 (Turnaround Time)**: 프로세스가 시스템에 제출된 시점부터 완료될 때까지 걸린 총 시간. 대기 시간 + 실행 시간 + I/O 시간.

4. **선점 스케줄링**: 스케줄러가 실행 중인 프로세스의 CPU를 강제로 빼앗을 수 있는 스케줄링 방식. 타임 슬라이스 만료, 높은 우선순위 프로세스 도착 등의 시점에 발생.

</details>

### 문제 2: 시간 계산

다음 프로세스에 대해 평균 대기 시간과 평균 총 처리 시간을 계산하세요.
(FCFS 스케줄링, 모든 프로세스가 시간 0에 도착)

| 프로세스 | 실행 시간 |
|---------|----------|
| P1 | 24 |
| P2 | 3 |
| P3 | 3 |

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
┌────────────────────────┬───┬───┐
│          P1            │P2 │P3 │
└────────────────────────┴───┴───┘
0                       24  27  30
```

**대기 시간:**
- P1: 0
- P2: 24
- P3: 27
- 평균 대기 시간 = (0 + 24 + 27) / 3 = 17

**총 처리 시간:**
- P1: 24 - 0 = 24
- P2: 27 - 0 = 27
- P3: 30 - 0 = 30
- 평균 총 처리 시간 = (24 + 27 + 30) / 3 = 27

</details>

### 문제 3: 스케줄러 식별

다음 설명에 맞는 스케줄러를 고르세요.

A. 장기 스케줄러
B. 단기 스케줄러
C. 중기 스케줄러

1. ( ) 밀리초 단위로 매우 자주 실행되어야 한다.
2. ( ) CPU-bound와 I/O-bound 프로세스를 적절히 섞어 선택한다.
3. ( ) 메모리가 부족할 때 프로세스를 디스크로 스왑한다.
4. ( ) CPU를 할당할 다음 프로세스를 결정한다.

<details>
<summary>정답 보기</summary>

1. (B) 단기 스케줄러 - 매우 자주 실행되어 빠른 알고리즘 필요
2. (A) 장기 스케줄러 - 시스템 균형을 위해 프로세스 혼합 고려
3. (C) 중기 스케줄러 - 스와핑 담당
4. (B) 단기 스케줄러 - CPU 스케줄링 담당

</details>

### 문제 4: 선점 vs 비선점

다음 상황에서 스케줄링 결정이 선점인지 비선점인지 구분하세요.

1. 프로세스가 exit()를 호출하여 종료
2. 타임 슬라이스가 만료되어 다른 프로세스로 전환
3. 프로세스가 I/O를 요청하여 대기 상태로 전환
4. 높은 우선순위의 프로세스가 Ready 큐에 도착하여 현재 프로세스를 중단

<details>
<summary>정답 보기</summary>

1. **비선점** - 프로세스가 자발적으로 종료
2. **선점** - 스케줄러가 강제로 CPU를 빼앗음
3. **비선점** - 프로세스가 자발적으로 CPU 반환
4. **선점** - 스케줄러가 강제로 CPU를 빼앗음

</details>

### 문제 5: 디스패처

디스패처가 수행하는 세 가지 주요 작업을 설명하고, 디스패치 지연 시간이 긴 경우 시스템에 어떤 영향을 미치는지 서술하세요.

<details>
<summary>정답 보기</summary>

**디스패처의 주요 작업:**
1. **컨텍스트 스위치**: 현재 프로세스의 상태(레지스터, PC 등)를 PCB에 저장하고, 새 프로세스의 상태를 PCB에서 복원
2. **모드 전환**: 커널 모드에서 사용자 모드로 전환
3. **점프**: 새 프로세스의 적절한 위치(PC가 가리키는 주소)로 제어 이동

**디스패치 지연 시간이 긴 경우의 영향:**
- CPU 이용률 감소 (실제 작업에 사용되는 시간 비율 감소)
- 응답 시간 증가 (사용자 요청에 대한 반응 느려짐)
- 처리량 감소 (단위 시간당 완료되는 프로세스 수 감소)
- 시스템 오버헤드 증가

</details>

---

## 다음 단계

- [05_Scheduling_Algorithms.md](./05_Scheduling_Algorithms.md) - FCFS, SJF, Priority, RR 알고리즘

---

## 참고 자료

- [OSTEP - CPU Scheduling](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf)
- [Operating System Concepts - Chapter 5](https://www.os-book.com/)
- [Linux Scheduler Documentation](https://www.kernel.org/doc/html/latest/scheduler/)

