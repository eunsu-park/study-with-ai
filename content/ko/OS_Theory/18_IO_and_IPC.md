# I/O와 IPC ⭐⭐⭐

## 개요

이 장에서는 운영체제의 입출력(I/O) 시스템과 프로세스 간 통신(IPC) 메커니즘을 학습합니다. 하드웨어 제어부터 고수준 통신 방법까지 다룹니다.

---

## 목차

1. [I/O 하드웨어](#1-io-하드웨어)
2. [I/O 방식](#2-io-방식)
3. [디바이스 드라이버](#3-디바이스-드라이버)
4. [버퍼링 전략](#4-버퍼링-전략)
5. [IPC 개요](#5-ipc-개요)
6. [파이프](#6-파이프)
7. [공유 메모리](#7-공유-메모리)
8. [메시지 큐와 소켓](#8-메시지-큐와-소켓)
9. [연습 문제](#연습-문제)

---

## 1. I/O 하드웨어

### 1.1 I/O 장치 분류

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        I/O 장치 분류                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌────────────────────────┬────────────────────────────────────────┐   │
│   │        분류            │              예시                       │   │
│   ├────────────────────────┼────────────────────────────────────────┤   │
│   │ 블록 장치              │ 하드 디스크, SSD, USB 저장장치         │   │
│   │ (Block Device)         │ - 고정 크기 블록 단위로 접근           │   │
│   │                        │ - 임의 접근 가능                       │   │
│   ├────────────────────────┼────────────────────────────────────────┤   │
│   │ 문자 장치              │ 키보드, 마우스, 프린터, 시리얼 포트    │   │
│   │ (Character Device)     │ - 바이트 스트림으로 접근               │   │
│   │                        │ - 순차 접근                            │   │
│   ├────────────────────────┼────────────────────────────────────────┤   │
│   │ 네트워크 장치          │ 이더넷, WiFi, Bluetooth                │   │
│   │ (Network Device)       │ - 패킷 기반                            │   │
│   │                        │ - 소켓 인터페이스                      │   │
│   └────────────────────────┴────────────────────────────────────────┘   │
│                                                                          │
│   Linux 장치 파일:                                                       │
│   /dev/sda       - 첫 번째 SCSI/SATA 디스크 (블록)                      │
│   /dev/tty1      - 첫 번째 터미널 (문자)                                │
│   /dev/null      - 널 장치 (문자)                                       │
│   /dev/random    - 난수 생성기 (문자)                                   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 I/O 하드웨어 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      I/O 하드웨어 구조                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │                            CPU                                    │  │
│   └───────────────────────────────┬──────────────────────────────────┘  │
│                                   │                                      │
│                                   ▼                                      │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │                        시스템 버스                                │  │
│   └──────┬─────────────┬─────────────┬─────────────┬────────────────┘  │
│          │             │             │             │                    │
│          ▼             ▼             ▼             ▼                    │
│   ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐          │
│   │  메모리    │ │ 디스크     │ │ 그래픽     │ │ 네트워크   │          │
│   │ 컨트롤러   │ │ 컨트롤러   │ │ 컨트롤러   │ │ 컨트롤러   │          │
│   └────────────┘ └─────┬──────┘ └─────┬──────┘ └─────┬──────┘          │
│                        │              │              │                  │
│                        ▼              ▼              ▼                  │
│                   ┌─────────┐   ┌─────────┐   ┌─────────┐              │
│                   │  HDD    │   │  GPU    │   │  NIC    │              │
│                   │  SSD    │   │         │   │         │              │
│                   └─────────┘   └─────────┘   └─────────┘              │
│                                                                          │
│   장치 컨트롤러 구성:                                                   │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  상태 레지스터    │ 명령 레지스터   │ 데이터 레지스터           │   │
│   │  (Status)         │ (Command)       │ (Data)                    │   │
│   │  - 준비/완료      │ - 읽기/쓰기     │ - I/O 데이터 버퍼        │   │
│   │  - 오류           │ - 제어 명령     │                           │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. I/O 방식

### 2.1 폴링 (Polling / Programmed I/O)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           폴링 방식                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   CPU가 반복적으로 장치 상태를 확인                                     │
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  CPU                          장치 컨트롤러                      │   │
│   │                                                                  │   │
│   │  1. 명령 전송 ──────────────────▶ 명령 레지스터                 │   │
│   │                                                                  │   │
│   │  2. while (상태 == busy) {    ◀── 상태 레지스터                 │   │
│   │        // 계속 확인 (CPU 낭비!)                                 │   │
│   │     }                                                            │   │
│   │                                                                  │   │
│   │  3. 데이터 전송 ──────────────▶/◀── 데이터 레지스터             │   │
│   │                                                                  │   │
│   │  4. 완료 확인                 ◀── 상태 레지스터                 │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   장점:                                                                  │
│   - 구현 간단                                                           │
│   - 빠른 장치에서는 오버헤드 적음                                       │
│                                                                          │
│   단점:                                                                  │
│   - CPU 시간 낭비 (Busy Waiting)                                        │
│   - 느린 장치에서 비효율적                                              │
│                                                                          │
│   사용 예: 빠른 네트워크 장치 (높은 처리량)                             │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 인터럽트 (Interrupt-Driven I/O)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        인터럽트 방식                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   시간 ──────────────────────────────────────────────────▶              │
│                                                                          │
│   CPU:    [다른 작업 수행]              [인터럽트 처리]  [다른 작업]    │
│                │                              ▲                          │
│                │ I/O 요청                     │ 인터럽트                 │
│                ▼                              │ 완료 신호                │
│   장치:       [I/O 작업 수행...............] │                          │
│                                               │                          │
│                                                                          │
│   인터럽트 처리 과정:                                                    │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                                                                  │   │
│   │  1. 장치가 인터럽트 신호 발생                                   │   │
│   │                                                                  │   │
│   │  2. CPU가 현재 작업 중단                                        │   │
│   │     - 레지스터 저장                                             │   │
│   │     - PC (Program Counter) 저장                                 │   │
│   │                                                                  │   │
│   │  3. 인터럽트 벡터 테이블 조회                                   │   │
│   │     인터럽트 번호 → 핸들러 주소                                 │   │
│   │                                                                  │   │
│   │  4. 인터럽트 핸들러 (ISR) 실행                                  │   │
│   │     - 장치 상태 확인                                            │   │
│   │     - 데이터 전송                                               │   │
│   │     - 대기 중인 프로세스 깨우기                                 │   │
│   │                                                                  │   │
│   │  5. 레지스터/PC 복원, 원래 작업 재개                            │   │
│   │                                                                  │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   장점: CPU가 I/O 대기 중 다른 작업 가능                                │
│   단점: 인터럽트 오버헤드, 빈번한 I/O에서 비효율적                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 DMA (Direct Memory Access)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                             DMA 방식                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   CPU 개입 없이 장치와 메모리 간 직접 데이터 전송                       │
│                                                                          │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │                                                                   │  │
│   │      ┌──────┐                    ┌─────────────────┐             │  │
│   │      │ CPU  │──(1) 설정───────▶│  DMA 컨트롤러   │             │  │
│   │      │      │◀─(4) 인터럽트────│                 │             │  │
│   │      └──────┘                    │  - 소스 주소    │             │  │
│   │         │                        │  - 목적지 주소  │             │  │
│   │         │ (다른 작업 수행)      │  - 바이트 수    │             │  │
│   │         │                        │  - 방향         │             │  │
│   │         │                        └────────┬────────┘             │  │
│   │         │                                 │                      │  │
│   │         ▼                         (2)(3) 직접 전송               │  │
│   │   ┌──────────┐                           │                      │  │
│   │   │  메모리   │◀──────────────────────────┘                      │  │
│   │   │          │                           │                      │  │
│   │   └──────────┘                           │                      │  │
│   │                                          │                      │  │
│   │                              ┌───────────▼───────────┐          │  │
│   │                              │      디스크 장치       │          │  │
│   │                              └───────────────────────┘          │  │
│   │                                                                   │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│   DMA 전송 과정:                                                        │
│   1. CPU가 DMA 컨트롤러에 전송 정보 설정                               │
│   2. DMA가 버스 사용하여 데이터 전송 (Cycle Stealing)                  │
│   3. 전송 중 CPU는 캐시/레지스터 작업 수행                             │
│   4. 전송 완료 시 DMA가 인터럽트 발생                                  │
│                                                                          │
│   장점: 대용량 데이터 전송 시 CPU 부하 최소화                          │
│   단점: DMA 컨트롤러 비용, 버스 경쟁                                   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 디바이스 드라이버

### 3.1 드라이버 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      디바이스 드라이버 계층                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     사용자 애플리케이션                          │   │
│   │                   (open, read, write, ioctl)                    │   │
│   └────────────────────────────┬────────────────────────────────────┘   │
│                                │ 시스템 콜                              │
│                                ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                         VFS 계층                                 │   │
│   │               (Virtual File System)                              │   │
│   │            장치 독립적인 추상화 인터페이스                       │   │
│   └────────────────────────────┬────────────────────────────────────┘   │
│                                │                                        │
│          ┌─────────────────────┼─────────────────────┐                 │
│          ▼                     ▼                     ▼                 │
│   ┌─────────────┐       ┌─────────────┐       ┌─────────────┐         │
│   │ 블록 드라이버│       │ 문자 드라이버│       │ 네트워크    │         │
│   │  (Block)    │       │ (Character) │       │ 드라이버    │         │
│   └──────┬──────┘       └──────┬──────┘       └──────┬──────┘         │
│          │                     │                     │                 │
│          ▼                     ▼                     ▼                 │
│   ┌─────────────┐       ┌─────────────┐       ┌─────────────┐         │
│   │ SCSI/SATA   │       │  TTY/Serial │       │  이더넷     │         │
│   │   드라이버   │       │   드라이버   │       │  드라이버    │         │
│   └──────┬──────┘       └──────┬──────┘       └──────┬──────┘         │
│          │                     │                     │                 │
│          ▼                     ▼                     ▼                 │
│   ┌─────────────┐       ┌─────────────┐       ┌─────────────┐         │
│   │    하드웨어   │       │    하드웨어   │       │    하드웨어   │         │
│   └─────────────┘       └─────────────┘       └─────────────┘         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Linux 드라이버 예시

```c
// 간단한 문자 디바이스 드라이버 구조
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "mydevice"

static int major_number;
static char device_buffer[1024];
static int open_count = 0;

// 장치 열기
static int device_open(struct inode *inode, struct file *file) {
    open_count++;
    printk(KERN_INFO "mydevice: opened %d time(s)\n", open_count);
    return 0;
}

// 장치 닫기
static int device_release(struct inode *inode, struct file *file) {
    printk(KERN_INFO "mydevice: closed\n");
    return 0;
}

// 장치에서 읽기
static ssize_t device_read(struct file *file, char __user *buffer,
                           size_t length, loff_t *offset) {
    int bytes_to_read = min(length, sizeof(device_buffer) - (size_t)*offset);

    if (*offset >= sizeof(device_buffer)) return 0;

    if (copy_to_user(buffer, device_buffer + *offset, bytes_to_read)) {
        return -EFAULT;
    }

    *offset += bytes_to_read;
    return bytes_to_read;
}

// 장치에 쓰기
static ssize_t device_write(struct file *file, const char __user *buffer,
                            size_t length, loff_t *offset) {
    int bytes_to_write = min(length, sizeof(device_buffer) - 1);

    if (copy_from_user(device_buffer, buffer, bytes_to_write)) {
        return -EFAULT;
    }

    device_buffer[bytes_to_write] = '\0';
    return bytes_to_write;
}

// 파일 연산 구조체
static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = device_open,
    .release = device_release,
    .read = device_read,
    .write = device_write,
};

// 모듈 초기화
static int __init mydevice_init(void) {
    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0) {
        printk(KERN_ALERT "Failed to register device\n");
        return major_number;
    }
    printk(KERN_INFO "mydevice: registered with major number %d\n",
           major_number);
    return 0;
}

// 모듈 정리
static void __exit mydevice_exit(void) {
    unregister_chrdev(major_number, DEVICE_NAME);
    printk(KERN_INFO "mydevice: unregistered\n");
}

module_init(mydevice_init);
module_exit(mydevice_exit);
MODULE_LICENSE("GPL");
```

---

## 4. 버퍼링 전략

### 4.1 버퍼링 유형

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         버퍼링 유형                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   1. 단일 버퍼링 (Single Buffering)                                     │
│   ┌─────────┐      ┌─────────┐      ┌─────────┐                        │
│   │ 장치    │ ───▶ │  버퍼   │ ───▶ │ 프로세스 │                        │
│   └─────────┘      └─────────┘      └─────────┘                        │
│                                                                          │
│   문제: 버퍼 처리 중 장치 대기                                          │
│                                                                          │
│   2. 이중 버퍼링 (Double Buffering)                                     │
│   ┌─────────┐      ┌─────────┐      ┌─────────┐                        │
│   │ 장치    │ ───▶ │ 버퍼 A  │ ───▶ │ 프로세스 │                        │
│   │         │      ├─────────┤      │         │                        │
│   │         │ ───▶ │ 버퍼 B  │ ───▶ │         │                        │
│   └─────────┘      └─────────┘      └─────────┘                        │
│                                                                          │
│   장치가 A에 쓰는 동안 프로세스는 B에서 읽음 (병렬 처리)               │
│                                                                          │
│   3. 순환 버퍼링 (Circular Buffering)                                   │
│                                                                          │
│        ┌───────────────────────────────────────┐                        │
│        │           순환 버퍼 큐                 │                        │
│        │    ┌───┬───┬───┬───┬───┬───┬───┐    │                        │
│        │    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │    │                        │
│        │    └───┴───┴───┴───┴───┴───┴───┘    │                        │
│        │        ↑               ↑             │                        │
│        │      head            tail            │                        │
│        │   (소비 위치)     (생산 위치)        │                        │
│        └───────────────────────────────────────┘                        │
│                                                                          │
│   생산자-소비자 패턴에서 효율적                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 스풀링 (Spooling)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          스풀링                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Simultaneous Peripheral Operations On-Line                            │
│                                                                          │
│   프린터 스풀링 예:                                                     │
│                                                                          │
│   ┌─────────┐                                                           │
│   │ 프로세스1│───┐                                                      │
│   └─────────┘   │    ┌─────────────────┐    ┌─────────────┐            │
│                 │    │                  │    │             │            │
│   ┌─────────┐   ├───▶│   스풀 디렉토리  │───▶│  프린터     │            │
│   │ 프로세스2│───┤    │   (디스크 큐)   │    │  데몬       │───▶ 프린터 │
│   └─────────┘   │    │                  │    │  (순차처리)  │            │
│                 │    │  job1.spl       │    └─────────────┘            │
│   ┌─────────┐   │    │  job2.spl       │                                │
│   │ 프로세스3│───┘    │  job3.spl       │                                │
│   └─────────┘         └─────────────────┘                                │
│                                                                          │
│   특징:                                                                  │
│   - 느린 장치 (프린터)를 가상화                                         │
│   - 여러 프로세스가 동시에 "출력" 가능                                  │
│   - 실제 출력은 순차적으로 처리                                         │
│   - 프로세스는 즉시 반환됨 (비동기)                                     │
│                                                                          │
│   다른 예: 메일 스풀, 배치 작업 큐                                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. IPC 개요

### 5.1 프로세스 간 통신 방식

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        IPC 방식 비교                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────────┬──────────────────────────────────────────────────┐ │
│  │      방식       │                    특징                          │ │
│  ├─────────────────┼──────────────────────────────────────────────────┤ │
│  │ 파이프 (Pipe)   │ - 단방향 (익명), 양방향 (명명)                  │ │
│  │                 │ - 부모-자식 프로세스 간 통신                    │ │
│  │                 │ - 바이트 스트림                                 │ │
│  ├─────────────────┼──────────────────────────────────────────────────┤ │
│  │ 공유 메모리     │ - 가장 빠름 (커널 개입 최소)                    │ │
│  │ (Shared Memory) │ - 동기화 필요 (세마포어 등)                     │ │
│  │                 │ - 대용량 데이터에 적합                          │ │
│  ├─────────────────┼──────────────────────────────────────────────────┤ │
│  │ 메시지 큐       │ - 구조화된 메시지                               │ │
│  │ (Message Queue) │ - 비동기 통신                                   │ │
│  │                 │ - 우선순위 지정 가능                            │ │
│  ├─────────────────┼──────────────────────────────────────────────────┤ │
│  │ 시그널 (Signal) │ - 비동기 알림                                   │ │
│  │                 │ - 제한된 정보 전달                              │ │
│  │                 │ - 인터럽트와 유사                               │ │
│  ├─────────────────┼──────────────────────────────────────────────────┤ │
│  │ 소켓 (Socket)   │ - 네트워크 통신                                 │ │
│  │                 │ - 다른 시스템 간 통신 가능                      │ │
│  │                 │ - TCP/UDP 프로토콜                              │ │
│  └─────────────────┴──────────────────────────────────────────────────┘ │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 파이프

### 6.1 익명 파이프 (Anonymous Pipe)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        익명 파이프                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   부모-자식 프로세스 간 단방향 통신                                     │
│                                                                          │
│   ┌─────────────┐                     ┌─────────────┐                   │
│   │   부모      │     파이프          │   자식      │                   │
│   │  프로세스   │                     │  프로세스   │                   │
│   │             │  ┌───────────────┐  │             │                   │
│   │ write(fd[1])│─▶│===============│─▶│ read(fd[0]) │                   │
│   │             │  └───────────────┘  │             │                   │
│   │  close(fd[0])                     │ close(fd[1])│                   │
│   └─────────────┘                     └─────────────┘                   │
│                                                                          │
│   fd[0]: 읽기 끝 (Read End)                                             │
│   fd[1]: 쓰기 끝 (Write End)                                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

```c
// 익명 파이프 예제
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[1024];

    // 파이프 생성
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(1);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }

    if (pid == 0) {
        // 자식 프로세스: 파이프에서 읽기
        close(pipefd[1]);  // 쓰기 끝 닫기

        ssize_t n = read(pipefd[0], buffer, sizeof(buffer));
        printf("자식이 받음: %.*s\n", (int)n, buffer);

        close(pipefd[0]);
        exit(0);
    } else {
        // 부모 프로세스: 파이프에 쓰기
        close(pipefd[0]);  // 읽기 끝 닫기

        const char* message = "Hello from parent!";
        write(pipefd[1], message, strlen(message));
        printf("부모가 보냄: %s\n", message);

        close(pipefd[1]);
        wait(NULL);
    }

    return 0;
}
```

### 6.2 명명 파이프 (Named Pipe / FIFO)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       명명 파이프 (FIFO)                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   파일 시스템에 이름을 가진 파이프                                      │
│   관련 없는 프로세스 간 통신 가능                                       │
│                                                                          │
│   ┌─────────────┐    /tmp/myfifo    ┌─────────────┐                    │
│   │ 프로세스 A  │                   │ 프로세스 B  │                    │
│   │             │  ┌────────────┐   │             │                    │
│   │ write() ───┼─▶│  FIFO 파일  │──▶│ read()     │                    │
│   │             │  └────────────┘   │             │                    │
│   └─────────────┘                   └─────────────┘                    │
│                                                                          │
│   $ mkfifo /tmp/myfifo   # 생성                                        │
│   $ ls -l /tmp/myfifo                                                   │
│   prw-r--r-- 1 user group 0 Jan 15 10:00 /tmp/myfifo                   │
│   # 'p'가 파이프 유형 표시                                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

```c
// FIFO 생성 및 사용
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#define FIFO_PATH "/tmp/myfifo"

// Writer 프로세스
void writer() {
    mkfifo(FIFO_PATH, 0666);

    int fd = open(FIFO_PATH, O_WRONLY);
    const char* message = "Hello via FIFO!";
    write(fd, message, strlen(message));
    close(fd);
}

// Reader 프로세스
void reader() {
    int fd = open(FIFO_PATH, O_RDONLY);
    char buffer[1024];
    ssize_t n = read(fd, buffer, sizeof(buffer));
    buffer[n] = '\0';
    printf("Received: %s\n", buffer);
    close(fd);
}
```

---

## 7. 공유 메모리

### 7.1 POSIX 공유 메모리

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        공유 메모리 구조                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   프로세스 A                         프로세스 B                         │
│   ┌─────────────────┐               ┌─────────────────┐                │
│   │ 가상 주소 공간   │               │ 가상 주소 공간   │                │
│   │                 │               │                 │                │
│   │ ┌─────────────┐ │               │ ┌─────────────┐ │                │
│   │ │    코드     │ │               │ │    코드     │ │                │
│   │ ├─────────────┤ │               │ ├─────────────┤ │                │
│   │ │   데이터    │ │               │ │   데이터    │ │                │
│   │ ├─────────────┤ │               │ ├─────────────┤ │                │
│   │ │ 공유 메모리  │◀┼───────────────┼▶│ 공유 메모리  │ │                │
│   │ │ (0x7000)    │ │      │        │ │ (0x9000)    │ │                │
│   │ ├─────────────┤ │      │        │ ├─────────────┤ │                │
│   │ │    힙       │ │      │        │ │    힙       │ │                │
│   │ └─────────────┘ │      │        │ └─────────────┘ │                │
│   └─────────────────┘      │        └─────────────────┘                │
│                            │                                            │
│                            ▼                                            │
│                  ┌─────────────────────┐                               │
│                  │     물리 메모리      │                               │
│                  │                     │                               │
│                  │    [공유 영역]       │                               │
│                  │   프레임 100-110    │                               │
│                  └─────────────────────┘                               │
│                                                                          │
│   같은 물리 메모리를 다른 가상 주소로 매핑                              │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

```c
// POSIX 공유 메모리 예제
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

#define SHM_NAME "/my_shm"
#define SHM_SIZE 4096

typedef struct {
    int counter;
    char message[256];
} SharedData;

int main() {
    // 공유 메모리 생성
    int fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    ftruncate(fd, SHM_SIZE);

    // 메모리 매핑
    SharedData* shared = mmap(NULL, SHM_SIZE,
                              PROT_READ | PROT_WRITE,
                              MAP_SHARED, fd, 0);

    // 초기화
    shared->counter = 0;
    strcpy(shared->message, "Hello!");

    pid_t pid = fork();

    if (pid == 0) {
        // 자식: 공유 메모리 읽기/수정
        printf("자식 읽음: counter=%d, message=%s\n",
               shared->counter, shared->message);

        shared->counter = 100;
        strcpy(shared->message, "Modified by child");

        munmap(shared, SHM_SIZE);
        exit(0);
    } else {
        // 부모: 자식 대기 후 확인
        wait(NULL);

        printf("부모 읽음: counter=%d, message=%s\n",
               shared->counter, shared->message);

        // 정리
        munmap(shared, SHM_SIZE);
        shm_unlink(SHM_NAME);
    }

    return 0;
}
```

### 7.2 동기화 필요성

```c
// 공유 메모리와 세마포어 동기화
#include <semaphore.h>

typedef struct {
    sem_t mutex;       // 상호 배제
    sem_t items;       // 아이템 수
    sem_t spaces;      // 빈 공간
    int buffer[10];
    int in, out;
} SharedBuffer;

// 생산자
void producer(SharedBuffer* sb, int item) {
    sem_wait(&sb->spaces);  // 빈 공간 대기
    sem_wait(&sb->mutex);   // 임계 구역

    sb->buffer[sb->in] = item;
    sb->in = (sb->in + 1) % 10;

    sem_post(&sb->mutex);   // 임계 구역 해제
    sem_post(&sb->items);   // 아이템 추가 알림
}

// 소비자
int consumer(SharedBuffer* sb) {
    sem_wait(&sb->items);   // 아이템 대기
    sem_wait(&sb->mutex);   // 임계 구역

    int item = sb->buffer[sb->out];
    sb->out = (sb->out + 1) % 10;

    sem_post(&sb->mutex);   // 임계 구역 해제
    sem_post(&sb->spaces);  // 빈 공간 추가 알림

    return item;
}
```

---

## 8. 메시지 큐와 소켓

### 8.1 POSIX 메시지 큐

```c
// 메시지 큐 예제
#include <mqueue.h>
#include <stdio.h>
#include <string.h>

#define QUEUE_NAME "/my_queue"

typedef struct {
    long type;
    char text[256];
} Message;

// 송신자
void sender() {
    struct mq_attr attr = {
        .mq_maxmsg = 10,
        .mq_msgsize = sizeof(Message)
    };

    mqd_t mq = mq_open(QUEUE_NAME, O_CREAT | O_WRONLY, 0666, &attr);

    Message msg;
    msg.type = 1;
    strcpy(msg.text, "Hello via Message Queue!");

    mq_send(mq, (char*)&msg, sizeof(msg), 0);
    mq_close(mq);
}

// 수신자
void receiver() {
    mqd_t mq = mq_open(QUEUE_NAME, O_RDONLY);

    Message msg;
    mq_receive(mq, (char*)&msg, sizeof(msg), NULL);

    printf("Received: %s\n", msg.text);

    mq_close(mq);
    mq_unlink(QUEUE_NAME);
}
```

### 8.2 소켓 통신

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         소켓 통신                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   서버                                     클라이언트                    │
│                                                                          │
│   socket() ─────────────────────────────── socket()                     │
│      │                                         │                        │
│      ▼                                         │                        │
│   bind()                                       │                        │
│      │                                         │                        │
│      ▼                                         │                        │
│   listen()                                     │                        │
│      │                                         │                        │
│      ▼                                         ▼                        │
│   accept() ◀───────── 연결 요청 ──────── connect()                     │
│      │                                         │                        │
│      │       ┌──────────────────────────┐     │                        │
│      ▼       │      데이터 교환          │     ▼                        │
│   read() ◀───│─────────────────────────▶│───write()                    │
│   write()────│─────────────────────────▶│───read()                     │
│      │       └──────────────────────────┘     │                        │
│      ▼                                         ▼                        │
│   close() ─────────────────────────────── close()                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

```c
// TCP 서버 예제
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080

int main() {
    int server_fd, client_fd;
    struct sockaddr_in address;
    socklen_t addrlen = sizeof(address);
    char buffer[1024] = {0};

    // 소켓 생성
    server_fd = socket(AF_INET, SOCK_STREAM, 0);

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // 바인딩
    bind(server_fd, (struct sockaddr*)&address, sizeof(address));

    // 리스닝
    listen(server_fd, 3);
    printf("Server listening on port %d\n", PORT);

    // 클라이언트 연결 수락
    client_fd = accept(server_fd, (struct sockaddr*)&address, &addrlen);

    // 데이터 수신
    read(client_fd, buffer, sizeof(buffer));
    printf("Received: %s\n", buffer);

    // 응답 송신
    send(client_fd, "Hello from server", 17, 0);

    close(client_fd);
    close(server_fd);
    return 0;
}
```

---

## 연습 문제

### 문제 1: I/O 방식 비교
폴링, 인터럽트, DMA의 적합한 사용 사례를 각각 제시하시오.

<details>
<summary>정답 보기</summary>

```
1. 폴링 (Polling):
   - 매우 빠른 장치 (고속 네트워크 카드)
   - 응답 시간이 매우 짧은 경우
   - 인터럽트 오버헤드를 피하고 싶을 때
   예: 10Gbps 네트워크, 저지연 트레이딩 시스템

2. 인터럽트 (Interrupt):
   - 느린 장치 (키보드, 마우스)
   - I/O 빈도가 낮은 경우
   - CPU가 다른 작업도 해야 하는 경우
   예: 일반 입력 장치, 저속 시리얼 포트

3. DMA (Direct Memory Access):
   - 대용량 데이터 전송
   - 블록 장치 (디스크, SSD)
   - 높은 처리량 필요
   예: 디스크 I/O, 비디오 캡처, 대용량 네트워크 전송
```

</details>

### 문제 2: 파이프 통신
다음 쉘 명령의 내부 동작을 파이프 관점에서 설명하시오.

```bash
$ cat file.txt | grep "error" | wc -l
```

<details>
<summary>정답 보기</summary>

```
1. 쉘이 두 개의 파이프 생성:
   pipe1: cat → grep
   pipe2: grep → wc

2. 세 개의 자식 프로세스 생성:

   프로세스 1 (cat):
   - stdout을 pipe1[1]로 리다이렉트
   - exec("cat", "file.txt")
   - 파일 내용을 pipe1에 쓰기

   프로세스 2 (grep):
   - stdin을 pipe1[0]으로 리다이렉트
   - stdout을 pipe2[1]로 리다이렉트
   - exec("grep", "error")
   - pipe1에서 읽어 "error" 필터링 후 pipe2에 쓰기

   프로세스 3 (wc):
   - stdin을 pipe2[0]으로 리다이렉트
   - exec("wc", "-l")
   - pipe2에서 읽어 라인 수 카운트

3. 데이터 흐름:
   file.txt → cat → pipe1 → grep → pipe2 → wc → stdout
```

</details>

### 문제 3: 공유 메모리 vs 메시지 패싱
프로듀서-컨슈머 문제를 구현할 때 공유 메모리와 메시지 큐의 장단점을 비교하시오.

<details>
<summary>정답 보기</summary>

```
공유 메모리:

장점:
- 가장 빠른 IPC (커널 개입 없음)
- 대용량 데이터에 효율적
- 유연한 데이터 구조 사용 가능

단점:
- 동기화 직접 구현 필요 (세마포어, 뮤텍스)
- 데이터 경합 조건 주의
- 단일 시스템에서만 사용 가능
- 메모리 관리 복잡

메시지 큐:

장점:
- 동기화 내장 (운영체제가 처리)
- 구조화된 메시지 전달
- 우선순위 지정 가능
- 메시지 경계 명확

단점:
- 데이터 복사 오버헤드
- 메시지 크기 제한
- 공유 메모리보다 느림

선택 기준:
- 대용량/고속: 공유 메모리
- 간편함/안전성: 메시지 큐
- 분산 시스템: 소켓 또는 네트워크 메시지 큐
```

</details>

### 문제 4: DMA 계산
1MB 파일을 디스크에서 읽을 때 DMA와 PIO(Programmed I/O)의 CPU 사용 시간을 비교하시오.

- 블록 크기: 512 바이트
- PIO: 블록당 CPU 100 사이클
- DMA: 설정 1000 사이클, 완료 인터럽트 500 사이클
- CPU 클럭: 1GHz

<details>
<summary>정답 보기</summary>

```
파일 크기: 1MB = 1,048,576 바이트
블록 수: 1,048,576 / 512 = 2,048 블록

PIO 방식:
- CPU 사이클 = 2,048 × 100 = 204,800 사이클
- CPU 시간 = 204,800 / 1,000,000,000 = 0.2048 ms

DMA 방식:
- 설정: 1,000 사이클
- 완료 인터럽트: 500 사이클
- 총 CPU 사이클 = 1,000 + 500 = 1,500 사이클
- CPU 시간 = 1,500 / 1,000,000,000 = 0.0015 ms

비교:
- PIO: 0.2048 ms
- DMA: 0.0015 ms
- DMA가 약 136배 더 효율적

추가 고려:
- DMA는 설정 오버헤드가 있어 매우 작은 전송에는 비효율적
- 손익분기점: 1500 / 100 = 15 블록 = 7.5 KB
- 7.5 KB 이상의 전송에서 DMA가 유리
```

</details>

### 문제 5: 소켓 프로그래밍
TCP와 UDP 소켓의 차이점을 설명하고, 각각 적합한 애플리케이션을 제시하시오.

<details>
<summary>정답 보기</summary>

```
TCP (Transmission Control Protocol):

특징:
- 연결 지향적 (3-way handshake)
- 신뢰성 보장 (순서, 재전송)
- 흐름 제어, 혼잡 제어
- 바이트 스트림

적합한 애플리케이션:
- 웹 (HTTP/HTTPS)
- 이메일 (SMTP, IMAP)
- 파일 전송 (FTP, SCP)
- 데이터베이스 연결
- SSH

UDP (User Datagram Protocol):

특징:
- 비연결형
- 신뢰성 없음 (손실 가능)
- 순서 보장 없음
- 데이터그램 기반
- 낮은 오버헤드

적합한 애플리케이션:
- 실시간 스트리밍 (비디오, 오디오)
- 온라인 게임
- DNS 쿼리
- VoIP
- IoT 센서 데이터

선택 기준:
- 신뢰성 필수: TCP
- 속도/저지연 우선: UDP
- 약간의 손실 허용: UDP
- 정확한 전달 필요: TCP
```

</details>

---

## 다음 단계

운영체제 이론 학습을 완료했습니다! 다음 단계로 추천하는 학습 경로:

### 심화 학습
- **[Linux](../Linux/)**: 실제 운영체제에서 학습 내용 적용
  - 프로세스 관리: `ps`, `top`, `kill`
  - 파일 시스템: `mount`, `df`, `du`
  - 네트워킹: `netstat`, `ss`, `iptables`

### 관련 분야
- **[Computer_Architecture](../Computer_Architecture/)**: 하드웨어 관점 이해
  - 메모리 계층 구조
  - 캐시 메모리
  - 입출력 시스템

### 실습 프로젝트
- 미니 쉘 구현 (프로세스 생성, 파이프)
- 메모리 할당자 구현
- 파일 시스템 시뮬레이터
- 스케줄러 시뮬레이터

---

## 참고 자료

- Silberschatz, "Operating System Concepts" Chapters 12-13
- Stevens, "Advanced Programming in the UNIX Environment"
- Linux man pages: `pipe(2)`, `mmap(2)`, `socket(2)`, `shm_open(3)`
- Linux kernel documentation: https://www.kernel.org/doc/html/latest/
- Tanenbaum, "Modern Operating Systems" Chapters 5-6
